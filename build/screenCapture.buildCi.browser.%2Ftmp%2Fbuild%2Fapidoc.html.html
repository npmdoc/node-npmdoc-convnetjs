<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://convnetjs.com">convnetjs (v0.3.0)</a>
</h1>
<h4>Deep Learning library. Supports Convolutional (and ordinary) Neural Networks</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs">module convnetjs</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.ConvLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>ConvLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.DropoutLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>DropoutLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.FullyConnLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>FullyConnLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.InputLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>InputLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.LocalResponseNormalizationLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>LocalResponseNormalizationLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.MagicNet">
            function <span class="apidocSignatureSpan">convnetjs.</span>MagicNet
            <span class="apidocSignatureSpan">(data, labels, opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.MaxoutLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>MaxoutLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Net">
            function <span class="apidocSignatureSpan">convnetjs.</span>Net
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.PoolLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>PoolLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.QuadTransformLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>QuadTransformLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.RegressionLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>RegressionLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.ReluLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>ReluLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.SGDTrainer">
            function <span class="apidocSignatureSpan">convnetjs.</span>SGDTrainer
            <span class="apidocSignatureSpan">(net, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.SVMLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>SVMLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.SigmoidLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>SigmoidLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.SoftmaxLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>SoftmaxLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.TanhLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>TanhLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Trainer">
            function <span class="apidocSignatureSpan">convnetjs.</span>Trainer
            <span class="apidocSignatureSpan">(net, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Vol">
            function <span class="apidocSignatureSpan">convnetjs.</span>Vol
            <span class="apidocSignatureSpan">(sx, sy, depth, c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.arrContains">
            function <span class="apidocSignatureSpan">convnetjs.</span>arrContains
            <span class="apidocSignatureSpan">(arr, elt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.arrUnique">
            function <span class="apidocSignatureSpan">convnetjs.</span>arrUnique
            <span class="apidocSignatureSpan">(arr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.augment">
            function <span class="apidocSignatureSpan">convnetjs.</span>augment
            <span class="apidocSignatureSpan">(V, crop, dx, dy, fliplr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.getopt">
            function <span class="apidocSignatureSpan">convnetjs.</span>getopt
            <span class="apidocSignatureSpan">(opt, field_name, default_value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.img_to_vol">
            function <span class="apidocSignatureSpan">convnetjs.</span>img_to_vol
            <span class="apidocSignatureSpan">(img, convert_grayscale)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.maxmin">
            function <span class="apidocSignatureSpan">convnetjs.</span>maxmin
            <span class="apidocSignatureSpan">(w)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.randf">
            function <span class="apidocSignatureSpan">convnetjs.</span>randf
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.randi">
            function <span class="apidocSignatureSpan">convnetjs.</span>randi
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.randn">
            function <span class="apidocSignatureSpan">convnetjs.</span>randn
            <span class="apidocSignatureSpan">(mu, std)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.randperm">
            function <span class="apidocSignatureSpan">convnetjs.</span>randperm
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.weightedSample">
            function <span class="apidocSignatureSpan">convnetjs.</span>weightedSample
            <span class="apidocSignatureSpan">(lst, probs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.zeros">
            function <span class="apidocSignatureSpan">convnetjs.</span>zeros
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">convnetjs.</span>ConvLayer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">convnetjs.</span>DropoutLayer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">convnetjs.</span>FullyConnLayer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">convnetjs.</span>InputLayer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">convnetjs.</span>LocalResponseNormalizationLayer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">convnetjs.</span>MagicNet.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">convnetjs.</span>MaxoutLayer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">convnetjs.</span>Net.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">convnetjs.</span>PoolLayer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">convnetjs.</span>QuadTransformLayer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">convnetjs.</span>RegressionLayer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">convnetjs.</span>ReluLayer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">convnetjs.</span>SVMLayer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">convnetjs.</span>SigmoidLayer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">convnetjs.</span>SoftmaxLayer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">convnetjs.</span>TanhLayer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">convnetjs.</span>Trainer.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">convnetjs.</span>Vol.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">convnetjs.</span>REVISION</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.ConvLayer">module convnetjs.ConvLayer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.ConvLayer.ConvLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>ConvLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.ConvLayer.prototype">module convnetjs.ConvLayer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.ConvLayer.prototype.backward">
            function <span class="apidocSignatureSpan">convnetjs.ConvLayer.prototype.</span>backward
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.ConvLayer.prototype.forward">
            function <span class="apidocSignatureSpan">convnetjs.ConvLayer.prototype.</span>forward
            <span class="apidocSignatureSpan">(V, is_training)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.ConvLayer.prototype.fromJSON">
            function <span class="apidocSignatureSpan">convnetjs.ConvLayer.prototype.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.ConvLayer.prototype.getParamsAndGrads">
            function <span class="apidocSignatureSpan">convnetjs.ConvLayer.prototype.</span>getParamsAndGrads
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.ConvLayer.prototype.toJSON">
            function <span class="apidocSignatureSpan">convnetjs.ConvLayer.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.DropoutLayer">module convnetjs.DropoutLayer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.DropoutLayer.DropoutLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>DropoutLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.DropoutLayer.prototype">module convnetjs.DropoutLayer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.DropoutLayer.prototype.backward">
            function <span class="apidocSignatureSpan">convnetjs.DropoutLayer.prototype.</span>backward
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.DropoutLayer.prototype.forward">
            function <span class="apidocSignatureSpan">convnetjs.DropoutLayer.prototype.</span>forward
            <span class="apidocSignatureSpan">(V, is_training)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.DropoutLayer.prototype.fromJSON">
            function <span class="apidocSignatureSpan">convnetjs.DropoutLayer.prototype.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.DropoutLayer.prototype.getParamsAndGrads">
            function <span class="apidocSignatureSpan">convnetjs.DropoutLayer.prototype.</span>getParamsAndGrads
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.DropoutLayer.prototype.toJSON">
            function <span class="apidocSignatureSpan">convnetjs.DropoutLayer.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.FullyConnLayer">module convnetjs.FullyConnLayer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.FullyConnLayer.FullyConnLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>FullyConnLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.FullyConnLayer.prototype">module convnetjs.FullyConnLayer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.FullyConnLayer.prototype.backward">
            function <span class="apidocSignatureSpan">convnetjs.FullyConnLayer.prototype.</span>backward
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.FullyConnLayer.prototype.forward">
            function <span class="apidocSignatureSpan">convnetjs.FullyConnLayer.prototype.</span>forward
            <span class="apidocSignatureSpan">(V, is_training)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.FullyConnLayer.prototype.fromJSON">
            function <span class="apidocSignatureSpan">convnetjs.FullyConnLayer.prototype.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.FullyConnLayer.prototype.getParamsAndGrads">
            function <span class="apidocSignatureSpan">convnetjs.FullyConnLayer.prototype.</span>getParamsAndGrads
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.FullyConnLayer.prototype.toJSON">
            function <span class="apidocSignatureSpan">convnetjs.FullyConnLayer.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.InputLayer">module convnetjs.InputLayer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.InputLayer.InputLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>InputLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.InputLayer.prototype">module convnetjs.InputLayer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.InputLayer.prototype.backward">
            function <span class="apidocSignatureSpan">convnetjs.InputLayer.prototype.</span>backward
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.InputLayer.prototype.forward">
            function <span class="apidocSignatureSpan">convnetjs.InputLayer.prototype.</span>forward
            <span class="apidocSignatureSpan">(V, is_training)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.InputLayer.prototype.fromJSON">
            function <span class="apidocSignatureSpan">convnetjs.InputLayer.prototype.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.InputLayer.prototype.getParamsAndGrads">
            function <span class="apidocSignatureSpan">convnetjs.InputLayer.prototype.</span>getParamsAndGrads
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.InputLayer.prototype.toJSON">
            function <span class="apidocSignatureSpan">convnetjs.InputLayer.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.LocalResponseNormalizationLayer">module convnetjs.LocalResponseNormalizationLayer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.LocalResponseNormalizationLayer.LocalResponseNormalizationLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>LocalResponseNormalizationLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.LocalResponseNormalizationLayer.prototype">module convnetjs.LocalResponseNormalizationLayer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.LocalResponseNormalizationLayer.prototype.backward">
            function <span class="apidocSignatureSpan">convnetjs.LocalResponseNormalizationLayer.prototype.</span>backward
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.LocalResponseNormalizationLayer.prototype.forward">
            function <span class="apidocSignatureSpan">convnetjs.LocalResponseNormalizationLayer.prototype.</span>forward
            <span class="apidocSignatureSpan">(V, is_training)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.LocalResponseNormalizationLayer.prototype.fromJSON">
            function <span class="apidocSignatureSpan">convnetjs.LocalResponseNormalizationLayer.prototype.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.LocalResponseNormalizationLayer.prototype.getParamsAndGrads">
            function <span class="apidocSignatureSpan">convnetjs.LocalResponseNormalizationLayer.prototype.</span>getParamsAndGrads
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.LocalResponseNormalizationLayer.prototype.toJSON">
            function <span class="apidocSignatureSpan">convnetjs.LocalResponseNormalizationLayer.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.MagicNet">module convnetjs.MagicNet</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.MagicNet.MagicNet">
            function <span class="apidocSignatureSpan">convnetjs.</span>MagicNet
            <span class="apidocSignatureSpan">(data, labels, opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.MagicNet.prototype">module convnetjs.MagicNet.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.MagicNet.prototype.evalValErrors">
            function <span class="apidocSignatureSpan">convnetjs.MagicNet.prototype.</span>evalValErrors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.MagicNet.prototype.fromJSON">
            function <span class="apidocSignatureSpan">convnetjs.MagicNet.prototype.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.MagicNet.prototype.onFinishBatch">
            function <span class="apidocSignatureSpan">convnetjs.MagicNet.prototype.</span>onFinishBatch
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.MagicNet.prototype.onFinishFold">
            function <span class="apidocSignatureSpan">convnetjs.MagicNet.prototype.</span>onFinishFold
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.MagicNet.prototype.predict">
            function <span class="apidocSignatureSpan">convnetjs.MagicNet.prototype.</span>predict
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.MagicNet.prototype.predict_soft">
            function <span class="apidocSignatureSpan">convnetjs.MagicNet.prototype.</span>predict_soft
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.MagicNet.prototype.sampleCandidate">
            function <span class="apidocSignatureSpan">convnetjs.MagicNet.prototype.</span>sampleCandidate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.MagicNet.prototype.sampleCandidates">
            function <span class="apidocSignatureSpan">convnetjs.MagicNet.prototype.</span>sampleCandidates
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.MagicNet.prototype.sampleFolds">
            function <span class="apidocSignatureSpan">convnetjs.MagicNet.prototype.</span>sampleFolds
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.MagicNet.prototype.step">
            function <span class="apidocSignatureSpan">convnetjs.MagicNet.prototype.</span>step
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.MagicNet.prototype.toJSON">
            function <span class="apidocSignatureSpan">convnetjs.MagicNet.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.MaxoutLayer">module convnetjs.MaxoutLayer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.MaxoutLayer.MaxoutLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>MaxoutLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.MaxoutLayer.prototype">module convnetjs.MaxoutLayer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.MaxoutLayer.prototype.backward">
            function <span class="apidocSignatureSpan">convnetjs.MaxoutLayer.prototype.</span>backward
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.MaxoutLayer.prototype.forward">
            function <span class="apidocSignatureSpan">convnetjs.MaxoutLayer.prototype.</span>forward
            <span class="apidocSignatureSpan">(V, is_training)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.MaxoutLayer.prototype.fromJSON">
            function <span class="apidocSignatureSpan">convnetjs.MaxoutLayer.prototype.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.MaxoutLayer.prototype.getParamsAndGrads">
            function <span class="apidocSignatureSpan">convnetjs.MaxoutLayer.prototype.</span>getParamsAndGrads
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.MaxoutLayer.prototype.toJSON">
            function <span class="apidocSignatureSpan">convnetjs.MaxoutLayer.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.Net">module convnetjs.Net</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Net.Net">
            function <span class="apidocSignatureSpan">convnetjs.</span>Net
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.Net.prototype">module convnetjs.Net.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Net.prototype.backward">
            function <span class="apidocSignatureSpan">convnetjs.Net.prototype.</span>backward
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Net.prototype.forward">
            function <span class="apidocSignatureSpan">convnetjs.Net.prototype.</span>forward
            <span class="apidocSignatureSpan">(V, is_training)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Net.prototype.fromJSON">
            function <span class="apidocSignatureSpan">convnetjs.Net.prototype.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Net.prototype.getParamsAndGrads">
            function <span class="apidocSignatureSpan">convnetjs.Net.prototype.</span>getParamsAndGrads
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Net.prototype.getPrediction">
            function <span class="apidocSignatureSpan">convnetjs.Net.prototype.</span>getPrediction
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Net.prototype.makeLayers">
            function <span class="apidocSignatureSpan">convnetjs.Net.prototype.</span>makeLayers
            <span class="apidocSignatureSpan">(defs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Net.prototype.toJSON">
            function <span class="apidocSignatureSpan">convnetjs.Net.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.PoolLayer">module convnetjs.PoolLayer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.PoolLayer.PoolLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>PoolLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.PoolLayer.prototype">module convnetjs.PoolLayer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.PoolLayer.prototype.backward">
            function <span class="apidocSignatureSpan">convnetjs.PoolLayer.prototype.</span>backward
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.PoolLayer.prototype.forward">
            function <span class="apidocSignatureSpan">convnetjs.PoolLayer.prototype.</span>forward
            <span class="apidocSignatureSpan">(V, is_training)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.PoolLayer.prototype.fromJSON">
            function <span class="apidocSignatureSpan">convnetjs.PoolLayer.prototype.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.PoolLayer.prototype.getParamsAndGrads">
            function <span class="apidocSignatureSpan">convnetjs.PoolLayer.prototype.</span>getParamsAndGrads
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.PoolLayer.prototype.toJSON">
            function <span class="apidocSignatureSpan">convnetjs.PoolLayer.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.QuadTransformLayer">module convnetjs.QuadTransformLayer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.QuadTransformLayer.QuadTransformLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>QuadTransformLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.QuadTransformLayer.prototype">module convnetjs.QuadTransformLayer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.QuadTransformLayer.prototype.backward">
            function <span class="apidocSignatureSpan">convnetjs.QuadTransformLayer.prototype.</span>backward
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.QuadTransformLayer.prototype.forward">
            function <span class="apidocSignatureSpan">convnetjs.QuadTransformLayer.prototype.</span>forward
            <span class="apidocSignatureSpan">(V, is_training)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.QuadTransformLayer.prototype.fromJSON">
            function <span class="apidocSignatureSpan">convnetjs.QuadTransformLayer.prototype.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.QuadTransformLayer.prototype.getParamsAndGrads">
            function <span class="apidocSignatureSpan">convnetjs.QuadTransformLayer.prototype.</span>getParamsAndGrads
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.QuadTransformLayer.prototype.toJSON">
            function <span class="apidocSignatureSpan">convnetjs.QuadTransformLayer.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.RegressionLayer">module convnetjs.RegressionLayer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.RegressionLayer.RegressionLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>RegressionLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.RegressionLayer.prototype">module convnetjs.RegressionLayer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.RegressionLayer.prototype.backward">
            function <span class="apidocSignatureSpan">convnetjs.RegressionLayer.prototype.</span>backward
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.RegressionLayer.prototype.forward">
            function <span class="apidocSignatureSpan">convnetjs.RegressionLayer.prototype.</span>forward
            <span class="apidocSignatureSpan">(V, is_training)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.RegressionLayer.prototype.fromJSON">
            function <span class="apidocSignatureSpan">convnetjs.RegressionLayer.prototype.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.RegressionLayer.prototype.getParamsAndGrads">
            function <span class="apidocSignatureSpan">convnetjs.RegressionLayer.prototype.</span>getParamsAndGrads
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.RegressionLayer.prototype.toJSON">
            function <span class="apidocSignatureSpan">convnetjs.RegressionLayer.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.ReluLayer">module convnetjs.ReluLayer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.ReluLayer.ReluLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>ReluLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.ReluLayer.prototype">module convnetjs.ReluLayer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.ReluLayer.prototype.backward">
            function <span class="apidocSignatureSpan">convnetjs.ReluLayer.prototype.</span>backward
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.ReluLayer.prototype.forward">
            function <span class="apidocSignatureSpan">convnetjs.ReluLayer.prototype.</span>forward
            <span class="apidocSignatureSpan">(V, is_training)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.ReluLayer.prototype.fromJSON">
            function <span class="apidocSignatureSpan">convnetjs.ReluLayer.prototype.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.ReluLayer.prototype.getParamsAndGrads">
            function <span class="apidocSignatureSpan">convnetjs.ReluLayer.prototype.</span>getParamsAndGrads
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.ReluLayer.prototype.toJSON">
            function <span class="apidocSignatureSpan">convnetjs.ReluLayer.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.SVMLayer">module convnetjs.SVMLayer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.SVMLayer.SVMLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>SVMLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.SVMLayer.prototype">module convnetjs.SVMLayer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.SVMLayer.prototype.backward">
            function <span class="apidocSignatureSpan">convnetjs.SVMLayer.prototype.</span>backward
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.SVMLayer.prototype.forward">
            function <span class="apidocSignatureSpan">convnetjs.SVMLayer.prototype.</span>forward
            <span class="apidocSignatureSpan">(V, is_training)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.SVMLayer.prototype.fromJSON">
            function <span class="apidocSignatureSpan">convnetjs.SVMLayer.prototype.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.SVMLayer.prototype.getParamsAndGrads">
            function <span class="apidocSignatureSpan">convnetjs.SVMLayer.prototype.</span>getParamsAndGrads
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.SVMLayer.prototype.toJSON">
            function <span class="apidocSignatureSpan">convnetjs.SVMLayer.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.SigmoidLayer">module convnetjs.SigmoidLayer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.SigmoidLayer.SigmoidLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>SigmoidLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.SigmoidLayer.prototype">module convnetjs.SigmoidLayer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.SigmoidLayer.prototype.backward">
            function <span class="apidocSignatureSpan">convnetjs.SigmoidLayer.prototype.</span>backward
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.SigmoidLayer.prototype.forward">
            function <span class="apidocSignatureSpan">convnetjs.SigmoidLayer.prototype.</span>forward
            <span class="apidocSignatureSpan">(V, is_training)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.SigmoidLayer.prototype.fromJSON">
            function <span class="apidocSignatureSpan">convnetjs.SigmoidLayer.prototype.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.SigmoidLayer.prototype.getParamsAndGrads">
            function <span class="apidocSignatureSpan">convnetjs.SigmoidLayer.prototype.</span>getParamsAndGrads
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.SigmoidLayer.prototype.toJSON">
            function <span class="apidocSignatureSpan">convnetjs.SigmoidLayer.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.SoftmaxLayer">module convnetjs.SoftmaxLayer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.SoftmaxLayer.SoftmaxLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>SoftmaxLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.SoftmaxLayer.prototype">module convnetjs.SoftmaxLayer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.SoftmaxLayer.prototype.backward">
            function <span class="apidocSignatureSpan">convnetjs.SoftmaxLayer.prototype.</span>backward
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.SoftmaxLayer.prototype.forward">
            function <span class="apidocSignatureSpan">convnetjs.SoftmaxLayer.prototype.</span>forward
            <span class="apidocSignatureSpan">(V, is_training)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.SoftmaxLayer.prototype.fromJSON">
            function <span class="apidocSignatureSpan">convnetjs.SoftmaxLayer.prototype.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.SoftmaxLayer.prototype.getParamsAndGrads">
            function <span class="apidocSignatureSpan">convnetjs.SoftmaxLayer.prototype.</span>getParamsAndGrads
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.SoftmaxLayer.prototype.toJSON">
            function <span class="apidocSignatureSpan">convnetjs.SoftmaxLayer.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.TanhLayer">module convnetjs.TanhLayer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.TanhLayer.TanhLayer">
            function <span class="apidocSignatureSpan">convnetjs.</span>TanhLayer
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.TanhLayer.prototype">module convnetjs.TanhLayer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.TanhLayer.prototype.backward">
            function <span class="apidocSignatureSpan">convnetjs.TanhLayer.prototype.</span>backward
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.TanhLayer.prototype.forward">
            function <span class="apidocSignatureSpan">convnetjs.TanhLayer.prototype.</span>forward
            <span class="apidocSignatureSpan">(V, is_training)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.TanhLayer.prototype.fromJSON">
            function <span class="apidocSignatureSpan">convnetjs.TanhLayer.prototype.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.TanhLayer.prototype.getParamsAndGrads">
            function <span class="apidocSignatureSpan">convnetjs.TanhLayer.prototype.</span>getParamsAndGrads
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.TanhLayer.prototype.toJSON">
            function <span class="apidocSignatureSpan">convnetjs.TanhLayer.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.Trainer">module convnetjs.Trainer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Trainer.Trainer">
            function <span class="apidocSignatureSpan">convnetjs.</span>Trainer
            <span class="apidocSignatureSpan">(net, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.Trainer.prototype">module convnetjs.Trainer.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Trainer.prototype.train">
            function <span class="apidocSignatureSpan">convnetjs.Trainer.prototype.</span>train
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.Vol">module convnetjs.Vol</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Vol.Vol">
            function <span class="apidocSignatureSpan">convnetjs.</span>Vol
            <span class="apidocSignatureSpan">(sx, sy, depth, c)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.convnetjs.Vol.prototype">module convnetjs.Vol.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Vol.prototype.add">
            function <span class="apidocSignatureSpan">convnetjs.Vol.prototype.</span>add
            <span class="apidocSignatureSpan">(x, y, d, v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Vol.prototype.addFrom">
            function <span class="apidocSignatureSpan">convnetjs.Vol.prototype.</span>addFrom
            <span class="apidocSignatureSpan">(V)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Vol.prototype.addFromScaled">
            function <span class="apidocSignatureSpan">convnetjs.Vol.prototype.</span>addFromScaled
            <span class="apidocSignatureSpan">(V, a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Vol.prototype.add_grad">
            function <span class="apidocSignatureSpan">convnetjs.Vol.prototype.</span>add_grad
            <span class="apidocSignatureSpan">(x, y, d, v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Vol.prototype.clone">
            function <span class="apidocSignatureSpan">convnetjs.Vol.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Vol.prototype.cloneAndZero">
            function <span class="apidocSignatureSpan">convnetjs.Vol.prototype.</span>cloneAndZero
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Vol.prototype.fromJSON">
            function <span class="apidocSignatureSpan">convnetjs.Vol.prototype.</span>fromJSON
            <span class="apidocSignatureSpan">(json)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Vol.prototype.get">
            function <span class="apidocSignatureSpan">convnetjs.Vol.prototype.</span>get
            <span class="apidocSignatureSpan">(x, y, d)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Vol.prototype.get_grad">
            function <span class="apidocSignatureSpan">convnetjs.Vol.prototype.</span>get_grad
            <span class="apidocSignatureSpan">(x, y, d)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Vol.prototype.set">
            function <span class="apidocSignatureSpan">convnetjs.Vol.prototype.</span>set
            <span class="apidocSignatureSpan">(x, y, d, v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Vol.prototype.setConst">
            function <span class="apidocSignatureSpan">convnetjs.Vol.prototype.</span>setConst
            <span class="apidocSignatureSpan">(a)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Vol.prototype.set_grad">
            function <span class="apidocSignatureSpan">convnetjs.Vol.prototype.</span>set_grad
            <span class="apidocSignatureSpan">(x, y, d, v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.convnetjs.Vol.prototype.toJSON">
            function <span class="apidocSignatureSpan">convnetjs.Vol.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs" id="apidoc.module.convnetjs">module convnetjs</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.ConvLayer" id="apidoc.element.convnetjs.ConvLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>ConvLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ConvLayer = function (opt) {
  var opt = opt || {};

  // required
  this.out_depth = opt.filters;
  this.sx = opt.sx; // filter size. Should be odd if possible, it's cleaner.
  this.in_depth = opt.in_depth;
  this.in_sx = opt.in_sx;
  this.in_sy = opt.in_sy;

  // optional
  this.sy = typeof opt.sy !== 'undefined' ? opt.sy : this.sx;
  this.stride = typeof opt.stride !== 'undefined' ? opt.stride : 1; // stride at which we apply filters to input volume
  this.pad = typeof opt.pad !== 'undefined' ? opt.pad : 0; // amount of 0 padding to add around borders of input volume
  this.l1_decay_mul = typeof opt.l1_decay_mul !== 'undefined' ? opt.l1_decay_mul : 0.0;
  this.l2_decay_mul = typeof opt.l2_decay_mul !== 'undefined' ? opt.l2_decay_mul : 1.0;

  // computed
  // note we are doing floor, so if the strided convolution of the filter doesnt fit into the input
  // volume exactly, the output volume will be trimmed and not contain the (incomplete) computed
  // final application.
  this.out_sx = Math.floor((this.in_sx + this.pad * 2 - this.sx) / this.stride + 1);
  this.out_sy = Math.floor((this.in_sy + this.pad * 2 - this.sy) / this.stride + 1);
  this.layer_type = 'conv';

  // initializations
  var bias = typeof opt.bias_pref !== 'undefined' ? opt.bias_pref : 0.0;
  this.filters = [];
  for(var i=0;i&lt;this.out_depth;i++) { this.filters.push(new Vol(this.sx, this.sy, this.in_depth)); }
  this.biases = new Vol(1, 1, this.out_depth, bias);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        switch(def.type) {
case 'fc': this.layers.push(new global.FullyConnLayer(def)); break;
case 'lrn': this.layers.push(new global.LocalResponseNormalizationLayer(def)); break;
case 'dropout': this.layers.push(new global.DropoutLayer(def)); break;
case 'input': this.layers.push(new global.InputLayer(def)); break;
case 'softmax': this.layers.push(new global.SoftmaxLayer(def)); break;
case 'regression': this.layers.push(new global.RegressionLayer(def)); break;
case 'conv': this.layers.push(new global.<span class="apidocCodeKeywordSpan">ConvLayer</span>(def)); break;
case 'pool': this.layers.push(new global.PoolLayer(def)); break;
case 'relu': this.layers.push(new global.ReluLayer(def)); break;
case 'sigmoid': this.layers.push(new global.SigmoidLayer(def)); break;
case 'tanh': this.layers.push(new global.TanhLayer(def)); break;
case 'maxout': this.layers.push(new global.MaxoutLayer(def)); break;
case 'quadtransform': this.layers.push(new global.QuadTransformLayer(def)); break;
case 'svm': this.layers.push(new global.SVMLayer(def)); break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.DropoutLayer" id="apidoc.element.convnetjs.DropoutLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>DropoutLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DropoutLayer = function (opt) {
  var opt = opt || {};

  // computed
  this.out_sx = opt.in_sx;
  this.out_sy = opt.in_sy;
  this.out_depth = opt.in_depth;
  this.layer_type = 'dropout';
  this.drop_prob = typeof opt.drop_prob !== 'undefined' ? opt.drop_prob : 0.5;
  this.dropped = global.zeros(this.out_sx*this.out_sy*this.out_depth);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  def.in_sy = prev.out_sy;
  def.in_depth = prev.out_depth;
}

switch(def.type) {
  case 'fc': this.layers.push(new global.FullyConnLayer(def)); break;
  case 'lrn': this.layers.push(new global.LocalResponseNormalizationLayer(def)); break;
  case 'dropout': this.layers.push(new global.<span class="apidocCodeKeywordSpan">DropoutLayer</span>(def)); break;
  case 'input': this.layers.push(new global.InputLayer(def)); break;
  case 'softmax': this.layers.push(new global.SoftmaxLayer(def)); break;
  case 'regression': this.layers.push(new global.RegressionLayer(def)); break;
  case 'conv': this.layers.push(new global.ConvLayer(def)); break;
  case 'pool': this.layers.push(new global.PoolLayer(def)); break;
  case 'relu': this.layers.push(new global.ReluLayer(def)); break;
  case 'sigmoid': this.layers.push(new global.SigmoidLayer(def)); break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.FullyConnLayer" id="apidoc.element.convnetjs.FullyConnLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>FullyConnLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">FullyConnLayer = function (opt) {
  var opt = opt || {};

  // required
  // ok fine we will allow 'filters' as the word as well
  this.out_depth = typeof opt.num_neurons !== 'undefined' ? opt.num_neurons : opt.filters;

  // optional
  this.l1_decay_mul = typeof opt.l1_decay_mul !== 'undefined' ? opt.l1_decay_mul : 0.0;
  this.l2_decay_mul = typeof opt.l2_decay_mul !== 'undefined' ? opt.l2_decay_mul : 1.0;

  // computed
  this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;
  this.out_sx = 1;
  this.out_sy = 1;
  this.layer_type = 'fc';

  // initializations
  var bias = typeof opt.bias_pref !== 'undefined' ? opt.bias_pref : 0.0;
  this.filters = [];
  for(var i=0;i&lt;this.out_depth ;i++) { this.filters.push(new Vol(1, 1, this.num_inputs)); }
  this.biases = new Vol(1, 1, this.out_depth, bias);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var prev = this.layers[i-1];
  def.in_sx = prev.out_sx;
  def.in_sy = prev.out_sy;
  def.in_depth = prev.out_depth;
}

switch(def.type) {
  case 'fc': this.layers.push(new global.<span class="apidocCodeKeywordSpan">FullyConnLayer</span>(def)); break;
  case 'lrn': this.layers.push(new global.LocalResponseNormalizationLayer(def)); break;
  case 'dropout': this.layers.push(new global.DropoutLayer(def)); break;
  case 'input': this.layers.push(new global.InputLayer(def)); break;
  case 'softmax': this.layers.push(new global.SoftmaxLayer(def)); break;
  case 'regression': this.layers.push(new global.RegressionLayer(def)); break;
  case 'conv': this.layers.push(new global.ConvLayer(def)); break;
  case 'pool': this.layers.push(new global.PoolLayer(def)); break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.InputLayer" id="apidoc.element.convnetjs.InputLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>InputLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">InputLayer = function (opt) {
  var opt = opt || {};

  // this is a bit silly but lets allow people to specify either ins or outs
  this.out_sx = typeof opt.out_sx !== 'undefined' ? opt.out_sx : opt.in_sx;
  this.out_sy = typeof opt.out_sy !== 'undefined' ? opt.out_sy : opt.in_sy;
  this.out_depth = typeof opt.out_depth !== 'undefined' ? opt.out_depth : opt.in_depth;
  this.layer_type = 'input';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  def.in_depth = prev.out_depth;
}

switch(def.type) {
  case 'fc': this.layers.push(new global.FullyConnLayer(def)); break;
  case 'lrn': this.layers.push(new global.LocalResponseNormalizationLayer(def)); break;
  case 'dropout': this.layers.push(new global.DropoutLayer(def)); break;
  case 'input': this.layers.push(new global.<span class="apidocCodeKeywordSpan">InputLayer</span>(def)); break;
  case 'softmax': this.layers.push(new global.SoftmaxLayer(def)); break;
  case 'regression': this.layers.push(new global.RegressionLayer(def)); break;
  case 'conv': this.layers.push(new global.ConvLayer(def)); break;
  case 'pool': this.layers.push(new global.PoolLayer(def)); break;
  case 'relu': this.layers.push(new global.ReluLayer(def)); break;
  case 'sigmoid': this.layers.push(new global.SigmoidLayer(def)); break;
  case 'tanh': this.layers.push(new global.TanhLayer(def)); break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.LocalResponseNormalizationLayer" id="apidoc.element.convnetjs.LocalResponseNormalizationLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>LocalResponseNormalizationLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">LocalResponseNormalizationLayer = function (opt) {
  var opt = opt || {};

  // required
  this.k = opt.k;
  this.n = opt.n;
  this.alpha = opt.alpha;
  this.beta = opt.beta;

  // computed
  this.out_sx = opt.in_sx;
  this.out_sy = opt.in_sy;
  this.out_depth = opt.in_depth;
  this.layer_type = 'lrn';

  // checks
  if(this.n%2 === 0) { console.log('WARNING n should be odd for LRN layer'); }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  def.in_sx = prev.out_sx;
  def.in_sy = prev.out_sy;
  def.in_depth = prev.out_depth;
}

switch(def.type) {
  case 'fc': this.layers.push(new global.FullyConnLayer(def)); break;
  case 'lrn': this.layers.push(new global.<span class="apidocCodeKeywordSpan">LocalResponseNormalizationLayer</span>(def
)); break;
  case 'dropout': this.layers.push(new global.DropoutLayer(def)); break;
  case 'input': this.layers.push(new global.InputLayer(def)); break;
  case 'softmax': this.layers.push(new global.SoftmaxLayer(def)); break;
  case 'regression': this.layers.push(new global.RegressionLayer(def)); break;
  case 'conv': this.layers.push(new global.ConvLayer(def)); break;
  case 'pool': this.layers.push(new global.PoolLayer(def)); break;
  case 'relu': this.layers.push(new global.ReluLayer(def)); break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.MagicNet" id="apidoc.element.convnetjs.MagicNet">
        function <span class="apidocSignatureSpan">convnetjs.</span>MagicNet
        <span class="apidocSignatureSpan">(data, labels, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MagicNet = function (data, labels, opt) {
  var opt = opt || {};
  if(typeof data === 'undefined') { data = []; }
  if(typeof labels === 'undefined') { labels = []; }

  // required inputs
  this.data = data; // store these pointers to data
  this.labels = labels;

  // optional inputs
  this.train_ratio = getopt(opt, 'train_ratio', 0.7);
  this.num_folds = getopt(opt, 'num_folds', 10);
  this.num_candidates = getopt(opt, 'num_candidates', 50); // we evaluate several in parallel
  // how many epochs of data to train every network? for every fold?
  // higher values mean higher accuracy in final results, but more expensive
  this.num_epochs = getopt(opt, 'num_epochs', 50);
  // number of best models to average during prediction. Usually higher = better
  this.ensemble_size = getopt(opt, 'ensemble_size', 10);

  // candidate parameters
  this.batch_size_min = getopt(opt, 'batch_size_min', 10);
  this.batch_size_max = getopt(opt, 'batch_size_max', 300);
  this.l2_decay_min = getopt(opt, 'l2_decay_min', -4);
  this.l2_decay_max = getopt(opt, 'l2_decay_max', 2);
  this.learning_rate_min = getopt(opt, 'learning_rate_min', -4);
  this.learning_rate_max = getopt(opt, 'learning_rate_max', 0);
  this.momentum_min = getopt(opt, 'momentum_min', 0.9);
  this.momentum_max = getopt(opt, 'momentum_max', 0.9);
  this.neurons_min = getopt(opt, 'neurons_min', 5);
  this.neurons_max = getopt(opt, 'neurons_max', 30);

  // computed
  this.folds = []; // data fold indices, gets filled by sampleFolds()
  this.candidates = []; // candidate networks that are being currently evaluated
  this.evaluated_candidates = []; // history of all candidates that were fully evaluated on all folds
  this.unique_labels = arrUnique(labels);
  this.iter = 0; // iteration counter, goes from 0 -&gt; num_epochs * num_training_data
  this.foldix = 0; // index of active fold

  // callbacks
  this.finish_fold_callback = null;
  this.finish_batch_callback = null;

  // initializations
  if(this.data.length &gt; 0) {
    this.sampleFolds();
    this.sampleCandidates();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.MaxoutLayer" id="apidoc.element.convnetjs.MaxoutLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>MaxoutLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MaxoutLayer = function (opt) {
  var opt = opt || {};

  // required
  this.group_size = typeof opt.group_size !== 'undefined' ? opt.group_size : 2;

  // computed
  this.out_sx = opt.in_sx;
  this.out_sy = opt.in_sy;
  this.out_depth = Math.floor(opt.in_depth / this.group_size);
  this.layer_type = 'maxout';

  this.switches = global.zeros(this.out_sx*this.out_sy*this.out_depth); // useful for backprop
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      case 'softmax': this.layers.push(new global.SoftmaxLayer(def)); break;
      case 'regression': this.layers.push(new global.RegressionLayer(def)); break;
      case 'conv': this.layers.push(new global.ConvLayer(def)); break;
      case 'pool': this.layers.push(new global.PoolLayer(def)); break;
      case 'relu': this.layers.push(new global.ReluLayer(def)); break;
      case 'sigmoid': this.layers.push(new global.SigmoidLayer(def)); break;
      case 'tanh': this.layers.push(new global.TanhLayer(def)); break;
      case 'maxout': this.layers.push(new global.<span class="apidocCodeKeywordSpan">MaxoutLayer</span>(def)); break;
      case 'quadtransform': this.layers.push(new global.QuadTransformLayer(def)); break;
      case 'svm': this.layers.push(new global.SVMLayer(def)); break;
      default: console.log('ERROR: UNRECOGNIZED LAYER TYPE!');
    }
  }
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.Net" id="apidoc.element.convnetjs.Net">
        function <span class="apidocSignatureSpan">convnetjs.</span>Net
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Net = function (options) {
  this.layers = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var hl = opt.hidden_layer_sizes;
    for(var k=0;k&lt;hl.length;k++) {
      layer_defs.push({type:'fc', num_neurons:hl[k], activation:'relu'}); // relu by default
    }
  }
  layer_defs.push({type:'regression', num_neurons:num_actions}); // value function output
}
this.value_net = new convnetjs.<span class="apidocCodeKeywordSpan">Net</span>();
this.value_net.makeLayers(layer_defs);

// and finally we need a Temporal Difference Learning trainer!
var tdtrainer_options = {learning_rate:0.01, momentum:0.0, batch_size:64, l2_decay:0.01};
if(typeof opt.tdtrainer_options !== 'undefined') {
  tdtrainer_options = opt.tdtrainer_options; // allow user to overwrite this
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.PoolLayer" id="apidoc.element.convnetjs.PoolLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>PoolLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PoolLayer = function (opt) {

  var opt = opt || {};

  // required
  this.sx = opt.sx; // filter size
  this.in_depth = opt.in_depth;
  this.in_sx = opt.in_sx;
  this.in_sy = opt.in_sy;

  // optional
  this.sy = typeof opt.sy !== 'undefined' ? opt.sy : this.sx;
  this.stride = typeof opt.stride !== 'undefined' ? opt.stride : 2;
  this.pad = typeof opt.pad !== 'undefined' ? opt.pad : 0; // amount of 0 padding to add around borders of input volume

  // computed
  this.out_depth = this.in_depth;
  this.out_sx = Math.floor((this.in_sx + this.pad * 2 - this.sx) / this.stride + 1);
  this.out_sy = Math.floor((this.in_sy + this.pad * 2 - this.sy) / this.stride + 1);
  this.layer_type = 'pool';
  // store switches for x,y coordinates for where the max comes from, for each output neuron
  this.switchx = global.zeros(this.out_sx*this.out_sy*this.out_depth);
  this.switchy = global.zeros(this.out_sx*this.out_sy*this.out_depth);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 'fc': this.layers.push(new global.FullyConnLayer(def)); break;
case 'lrn': this.layers.push(new global.LocalResponseNormalizationLayer(def)); break;
case 'dropout': this.layers.push(new global.DropoutLayer(def)); break;
case 'input': this.layers.push(new global.InputLayer(def)); break;
case 'softmax': this.layers.push(new global.SoftmaxLayer(def)); break;
case 'regression': this.layers.push(new global.RegressionLayer(def)); break;
case 'conv': this.layers.push(new global.ConvLayer(def)); break;
case 'pool': this.layers.push(new global.<span class="apidocCodeKeywordSpan">PoolLayer</span>(def)); break;
case 'relu': this.layers.push(new global.ReluLayer(def)); break;
case 'sigmoid': this.layers.push(new global.SigmoidLayer(def)); break;
case 'tanh': this.layers.push(new global.TanhLayer(def)); break;
case 'maxout': this.layers.push(new global.MaxoutLayer(def)); break;
case 'quadtransform': this.layers.push(new global.QuadTransformLayer(def)); break;
case 'svm': this.layers.push(new global.SVMLayer(def)); break;
default: console.log('ERROR: UNRECOGNIZED LAYER TYPE!');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.QuadTransformLayer" id="apidoc.element.convnetjs.QuadTransformLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>QuadTransformLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">QuadTransformLayer = function (opt) {
  var opt = opt || {};

  // computed
  this.out_sx = opt.in_sx;
  this.out_sy = opt.in_sy;
  // linear terms, and then quadratic terms, of which there are 1/2*n*(n+1),
  // (offdiagonals and the diagonal total) and arithmetic series.
  // Actually never mind, lets not be fancy here yet and just include
  // terms x_ix_j and x_jx_i twice. Half as efficient but much less
  // headache.
  this.out_depth = opt.in_depth + opt.in_depth * opt.in_depth;
  this.layer_type = 'quadtransform';

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      case 'regression': this.layers.push(new global.RegressionLayer(def)); break;
      case 'conv': this.layers.push(new global.ConvLayer(def)); break;
      case 'pool': this.layers.push(new global.PoolLayer(def)); break;
      case 'relu': this.layers.push(new global.ReluLayer(def)); break;
      case 'sigmoid': this.layers.push(new global.SigmoidLayer(def)); break;
      case 'tanh': this.layers.push(new global.TanhLayer(def)); break;
      case 'maxout': this.layers.push(new global.MaxoutLayer(def)); break;
      case 'quadtransform': this.layers.push(new global.<span class="apidocCodeKeywordSpan">QuadTransformLayer</span>(
def)); break;
      case 'svm': this.layers.push(new global.SVMLayer(def)); break;
      default: console.log('ERROR: UNRECOGNIZED LAYER TYPE!');
    }
  }
},

// forward prop the network. A trainer will pass in is_training = true
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.RegressionLayer" id="apidoc.element.convnetjs.RegressionLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>RegressionLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RegressionLayer = function (opt) {
  var opt = opt || {};

  // computed
  this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;
  this.out_depth = this.num_inputs;
  this.out_sx = 1;
  this.out_sy = 1;
  this.layer_type = 'regression';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        switch(def.type) {
case 'fc': this.layers.push(new global.FullyConnLayer(def)); break;
case 'lrn': this.layers.push(new global.LocalResponseNormalizationLayer(def)); break;
case 'dropout': this.layers.push(new global.DropoutLayer(def)); break;
case 'input': this.layers.push(new global.InputLayer(def)); break;
case 'softmax': this.layers.push(new global.SoftmaxLayer(def)); break;
case 'regression': this.layers.push(new global.<span class="apidocCodeKeywordSpan">RegressionLayer</span>(def)); break
;
case 'conv': this.layers.push(new global.ConvLayer(def)); break;
case 'pool': this.layers.push(new global.PoolLayer(def)); break;
case 'relu': this.layers.push(new global.ReluLayer(def)); break;
case 'sigmoid': this.layers.push(new global.SigmoidLayer(def)); break;
case 'tanh': this.layers.push(new global.TanhLayer(def)); break;
case 'maxout': this.layers.push(new global.MaxoutLayer(def)); break;
case 'quadtransform': this.layers.push(new global.QuadTransformLayer(def)); break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.ReluLayer" id="apidoc.element.convnetjs.ReluLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>ReluLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ReluLayer = function (opt) {
  var opt = opt || {};

  // computed
  this.out_sx = opt.in_sx;
  this.out_sy = opt.in_sy;
  this.out_depth = opt.in_depth;
  this.layer_type = 'relu';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  case 'lrn': this.layers.push(new global.LocalResponseNormalizationLayer(def)); break;
  case 'dropout': this.layers.push(new global.DropoutLayer(def)); break;
  case 'input': this.layers.push(new global.InputLayer(def)); break;
  case 'softmax': this.layers.push(new global.SoftmaxLayer(def)); break;
  case 'regression': this.layers.push(new global.RegressionLayer(def)); break;
  case 'conv': this.layers.push(new global.ConvLayer(def)); break;
  case 'pool': this.layers.push(new global.PoolLayer(def)); break;
  case 'relu': this.layers.push(new global.<span class="apidocCodeKeywordSpan">ReluLayer</span>(def)); break;
  case 'sigmoid': this.layers.push(new global.SigmoidLayer(def)); break;
  case 'tanh': this.layers.push(new global.TanhLayer(def)); break;
  case 'maxout': this.layers.push(new global.MaxoutLayer(def)); break;
  case 'quadtransform': this.layers.push(new global.QuadTransformLayer(def)); break;
  case 'svm': this.layers.push(new global.SVMLayer(def)); break;
  default: console.log('ERROR: UNRECOGNIZED LAYER TYPE!');
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.SGDTrainer" id="apidoc.element.convnetjs.SGDTrainer">
        function <span class="apidocSignatureSpan">convnetjs.</span>SGDTrainer
        <span class="apidocSignatureSpan">(net, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SGDTrainer = function (net, options) {

  this.net = net;

  var options = options || {};
  this.learning_rate = typeof options.learning_rate !== 'undefined' ? options.learning_rate : 0.01;
  this.l1_decay = typeof options.l1_decay !== 'undefined' ? options.l1_decay : 0.0;
  this.l2_decay = typeof options.l2_decay !== 'undefined' ? options.l2_decay : 0.0;
  this.batch_size = typeof options.batch_size !== 'undefined' ? options.batch_size : 1;
  this.method = typeof options.method !== 'undefined' ? options.method : 'sgd'; // sgd/adagrad/adadelta/windowgrad

  this.momentum = typeof options.momentum !== 'undefined' ? options.momentum : 0.9;
  this.ro = typeof options.ro !== 'undefined' ? options.ro : 0.95; // used in adadelta
  this.eps = typeof options.eps !== 'undefined' ? options.eps : 1e-6; // used in adadelta

  this.k = 0; // iteration counter
  this.gsum = []; // last iteration gradients (used for momentum calculations)
  this.xsum = []; // used in adadelta
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.value_net.makeLayers(layer_defs);

// and finally we need a Temporal Difference Learning trainer!
var tdtrainer_options = {learning_rate:0.01, momentum:0.0, batch_size:64, l2_decay:0.01};
if(typeof opt.tdtrainer_options !== 'undefined') {
  tdtrainer_options = opt.tdtrainer_options; // allow user to overwrite this
}
this.tdtrainer = new convnetjs.<span class="apidocCodeKeywordSpan">SGDTrainer</span>(this.value_net, tdtrainer_options);

// experience replay
this.experience = [];

// various housekeeping variables
this.age = 0; // incremented every backward()
this.forward_passes = 0; // incremented every forward()
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.SVMLayer" id="apidoc.element.convnetjs.SVMLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>SVMLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SVMLayer = function (opt) {
  var opt = opt || {};

  // computed
  this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;
  this.out_depth = this.num_inputs;
  this.out_sx = 1;
  this.out_sy = 1;
  this.layer_type = 'svm';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      case 'conv': this.layers.push(new global.ConvLayer(def)); break;
      case 'pool': this.layers.push(new global.PoolLayer(def)); break;
      case 'relu': this.layers.push(new global.ReluLayer(def)); break;
      case 'sigmoid': this.layers.push(new global.SigmoidLayer(def)); break;
      case 'tanh': this.layers.push(new global.TanhLayer(def)); break;
      case 'maxout': this.layers.push(new global.MaxoutLayer(def)); break;
      case 'quadtransform': this.layers.push(new global.QuadTransformLayer(def)); break;
      case 'svm': this.layers.push(new global.<span class="apidocCodeKeywordSpan">SVMLayer</span>(def)); break;
      default: console.log('ERROR: UNRECOGNIZED LAYER TYPE!');
    }
  }
},

// forward prop the network. A trainer will pass in is_training = true
forward: function(V, is_training) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.SigmoidLayer" id="apidoc.element.convnetjs.SigmoidLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>SigmoidLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SigmoidLayer = function (opt) {
  var opt = opt || {};

  // computed
  this.out_sx = opt.in_sx;
  this.out_sy = opt.in_sy;
  this.out_depth = opt.in_depth;
  this.layer_type = 'sigmoid';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    case 'dropout': this.layers.push(new global.DropoutLayer(def)); break;
    case 'input': this.layers.push(new global.InputLayer(def)); break;
    case 'softmax': this.layers.push(new global.SoftmaxLayer(def)); break;
    case 'regression': this.layers.push(new global.RegressionLayer(def)); break;
    case 'conv': this.layers.push(new global.ConvLayer(def)); break;
    case 'pool': this.layers.push(new global.PoolLayer(def)); break;
    case 'relu': this.layers.push(new global.ReluLayer(def)); break;
    case 'sigmoid': this.layers.push(new global.<span class="apidocCodeKeywordSpan">SigmoidLayer</span>(def)); break;
    case 'tanh': this.layers.push(new global.TanhLayer(def)); break;
    case 'maxout': this.layers.push(new global.MaxoutLayer(def)); break;
    case 'quadtransform': this.layers.push(new global.QuadTransformLayer(def)); break;
    case 'svm': this.layers.push(new global.SVMLayer(def)); break;
    default: console.log('ERROR: UNRECOGNIZED LAYER TYPE!');
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.SoftmaxLayer" id="apidoc.element.convnetjs.SoftmaxLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>SoftmaxLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SoftmaxLayer = function (opt) {
  var opt = opt || {};

  // computed
  this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;
  this.out_depth = this.num_inputs;
  this.out_sx = 1;
  this.out_sy = 1;
  this.layer_type = 'softmax';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

switch(def.type) {
  case 'fc': this.layers.push(new global.FullyConnLayer(def)); break;
  case 'lrn': this.layers.push(new global.LocalResponseNormalizationLayer(def)); break;
  case 'dropout': this.layers.push(new global.DropoutLayer(def)); break;
  case 'input': this.layers.push(new global.InputLayer(def)); break;
  case 'softmax': this.layers.push(new global.<span class="apidocCodeKeywordSpan">SoftmaxLayer</span>(def)); break;
  case 'regression': this.layers.push(new global.RegressionLayer(def)); break;
  case 'conv': this.layers.push(new global.ConvLayer(def)); break;
  case 'pool': this.layers.push(new global.PoolLayer(def)); break;
  case 'relu': this.layers.push(new global.ReluLayer(def)); break;
  case 'sigmoid': this.layers.push(new global.SigmoidLayer(def)); break;
  case 'tanh': this.layers.push(new global.TanhLayer(def)); break;
  case 'maxout': this.layers.push(new global.MaxoutLayer(def)); break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.TanhLayer" id="apidoc.element.convnetjs.TanhLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>TanhLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TanhLayer = function (opt) {
  var opt = opt || {};

  // computed
  this.out_sx = opt.in_sx;
  this.out_sy = opt.in_sy;
  this.out_depth = opt.in_depth;
  this.layer_type = 'tanh';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      case 'input': this.layers.push(new global.InputLayer(def)); break;
      case 'softmax': this.layers.push(new global.SoftmaxLayer(def)); break;
      case 'regression': this.layers.push(new global.RegressionLayer(def)); break;
      case 'conv': this.layers.push(new global.ConvLayer(def)); break;
      case 'pool': this.layers.push(new global.PoolLayer(def)); break;
      case 'relu': this.layers.push(new global.ReluLayer(def)); break;
      case 'sigmoid': this.layers.push(new global.SigmoidLayer(def)); break;
      case 'tanh': this.layers.push(new global.<span class="apidocCodeKeywordSpan">TanhLayer</span>(def)); break;
      case 'maxout': this.layers.push(new global.MaxoutLayer(def)); break;
      case 'quadtransform': this.layers.push(new global.QuadTransformLayer(def)); break;
      case 'svm': this.layers.push(new global.SVMLayer(def)); break;
      default: console.log('ERROR: UNRECOGNIZED LAYER TYPE!');
    }
  }
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.Trainer" id="apidoc.element.convnetjs.Trainer">
        function <span class="apidocSignatureSpan">convnetjs.</span>Trainer
        <span class="apidocSignatureSpan">(net, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Trainer = function (net, options) {

  this.net = net;

  var options = options || {};
  this.learning_rate = typeof options.learning_rate !== 'undefined' ? options.learning_rate : 0.01;
  this.l1_decay = typeof options.l1_decay !== 'undefined' ? options.l1_decay : 0.0;
  this.l2_decay = typeof options.l2_decay !== 'undefined' ? options.l2_decay : 0.0;
  this.batch_size = typeof options.batch_size !== 'undefined' ? options.batch_size : 1;
  this.method = typeof options.method !== 'undefined' ? options.method : 'sgd'; // sgd/adagrad/adadelta/windowgrad

  this.momentum = typeof options.momentum !== 'undefined' ? options.momentum : 0.9;
  this.ro = typeof options.ro !== 'undefined' ? options.ro : 0.95; // used in adadelta
  this.eps = typeof options.eps !== 'undefined' ? options.eps : 1e-6; // used in adadelta

  this.k = 0; // iteration counter
  this.gsum = []; // last iteration gradients (used for momentum calculations)
  this.xsum = []; // used in adadelta
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.Vol" id="apidoc.element.convnetjs.Vol">
        function <span class="apidocSignatureSpan">convnetjs.</span>Vol
        <span class="apidocSignatureSpan">(sx, sy, depth, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Vol = function (sx, sy, depth, c) {
  // this is how you check if a variable is an array. Oh, Javascript :)
  if(Object.prototype.toString.call(sx) === '[object Array]') {
    // we were given a list in sx, assume 1D volume and fill it up
    this.sx = 1;
    this.sy = 1;
    this.depth = sx.length;
    // we have to do the following copy because we want to use
    // fast typed arrays, not an ordinary javascript array
    this.w = global.zeros(this.depth);
    this.dw = global.zeros(this.depth);
    for(var i=0;i&lt;this.depth;i++) {
      this.w[i] = sx[i];
    }
  } else {
    // we were given dimensions of the vol
    this.sx = sx;
    this.sy = sy;
    this.depth = depth;
    var n = sx*sy*depth;
    this.w = global.zeros(n);
    this.dw = global.zeros(n);
    if(typeof c === 'undefined') {
      // weight normalization is done to equalize the output
      // variance of every neuron, otherwise neurons with a lot
      // of incoming connections have outputs of larger variance
      var scale = Math.sqrt(1.0/(sx*sy*depth));
      for(var i=0;i&lt;n;i++) {
        this.w[i] = global.randn(0.0, scale);
      }
    } else {
      for(var i=0;i&lt;n;i++) {
        this.w[i] = c;
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var maxmin = global.maxmin;
var randperm = global.randperm;
var weightedSample = global.weightedSample;
var getopt = global.getopt;
var arrUnique = global.arrUnique;

/*
A MagicNet takes data: a list of convnetjs.<span class="apidocCodeKeywordSpan">Vol</span>(), and labels
which for now are assumed to be class indeces 0..K. MagicNet then:
- creates data folds for cross-validation
- samples candidate networks
- evaluates candidate networks on all data folds
- produces predictions by model-averaging the best networks
*/
var MagicNet = function(data, labels, opt) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.arrContains" id="apidoc.element.convnetjs.arrContains">
        function <span class="apidocSignatureSpan">convnetjs.</span>arrContains
        <span class="apidocSignatureSpan">(arr, elt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrContains = function (arr, elt) {
  for(var i=0,n=arr.length;i&lt;n;i++) {
    if(arr[i]===elt) return true;
  }
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.arrUnique" id="apidoc.element.convnetjs.arrUnique">
        function <span class="apidocSignatureSpan">convnetjs.</span>arrUnique
        <span class="apidocSignatureSpan">(arr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrUnique = function (arr) {
  var b = [];
  for(var i=0,n=arr.length;i&lt;n;i++) {
    if(!arrContains(b, arr[i])) {
      b.push(arr[i]);
    }
  }
  return b;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.augment" id="apidoc.element.convnetjs.augment">
        function <span class="apidocSignatureSpan">convnetjs.</span>augment
        <span class="apidocSignatureSpan">(V, crop, dx, dy, fliplr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">augment = function (V, crop, dx, dy, fliplr) {
  // note assumes square outputs of size crop x crop
  if(typeof(fliplr)==='undefined') var fliplr = false;
  if(typeof(dx)==='undefined') var dx = global.randi(0, V.sx - crop);
  if(typeof(dy)==='undefined') var dy = global.randi(0, V.sy - crop);

  // randomly sample a crop in the input volume
  var W;
  if(crop !== V.sx || dx!==0 || dy!==0) {
    W = new Vol(crop, crop, V.depth, 0.0);
    for(var x=0;x&lt;crop;x++) {
      for(var y=0;y&lt;crop;y++) {
        if(x+dx&lt;0 || x+dx&gt;=V.sx || y+dy&lt;0 || y+dy&gt;=V.sy) continue; // oob
        for(var d=0;d&lt;V.depth;d++) {
         W.set(x,y,d,V.get(x+dx,y+dy,d)); // copy data over
        }
      }
    }
  } else {
    W = V;
  }

  if(fliplr) {
    // flip volume horziontally
    var W2 = W.cloneAndZero();
    for(var x=0;x&lt;W.sx;x++) {
      for(var y=0;y&lt;W.sy;y++) {
        for(var d=0;d&lt;W.depth;d++) {
         W2.set(x,y,d,W.get(W.sx - x - 1,y,d)); // copy data over
        }
      }
    }
    W = W2; //swap
  }
  return W;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.getopt" id="apidoc.element.convnetjs.getopt">
        function <span class="apidocSignatureSpan">convnetjs.</span>getopt
        <span class="apidocSignatureSpan">(opt, field_name, default_value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getopt = function (opt, field_name, default_value) {
  return typeof opt[field_name] !== 'undefined' ? opt[field_name] : default_value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.img_to_vol" id="apidoc.element.convnetjs.img_to_vol">
        function <span class="apidocSignatureSpan">convnetjs.</span>img_to_vol
        <span class="apidocSignatureSpan">(img, convert_grayscale)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">img_to_vol = function (img, convert_grayscale) {

  if(typeof(convert_grayscale)==='undefined') var convert_grayscale = false;

  var canvas = document.createElement('canvas');
  canvas.width = img.width;
  canvas.height = img.height;
  var ctx = canvas.getContext("2d");

  // due to a Firefox bug
  try {
    ctx.drawImage(img, 0, 0);
  } catch (e) {
    if (e.name === "NS_ERROR_NOT_AVAILABLE") {
      // sometimes happens, lets just abort
      return false;
    } else {
      throw e;
    }
  }

  try {
    var img_data = ctx.getImageData(0, 0, canvas.width, canvas.height);
  } catch (e) {
    if(e.name === 'IndexSizeError') {
      return false; // not sure what causes this sometimes but okay abort
    } else {
      throw e;
    }
  }

  // prepare the input: get pixels and normalize them
  var p = img_data.data;
  var W = img.width;
  var H = img.height;
  var pv = []
  for(var i=0;i&lt;p.length;i++) {
    pv.push(p[i]/255.0-0.5); // normalize image pixels to [-0.5, 0.5]
  }
  var x = new Vol(W, H, 4, 0.0); //input volume (image)
  x.w = pv;

  if(convert_grayscale) {
    // flatten into depth=1 array
    var x1 = new Vol(W, H, 1, 0.0);
    for(var i=0;i&lt;W;i++) {
      for(var j=0;j&lt;H;j++) {
        x1.set(i,j,0,x.get(i,j,0));
      }
    }
    x = x1;
  }

  return x;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.maxmin" id="apidoc.element.convnetjs.maxmin">
        function <span class="apidocSignatureSpan">convnetjs.</span>maxmin
        <span class="apidocSignatureSpan">(w)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maxmin = function (w) {
  if(w.length === 0) { return {}; } // ... ;s
  var maxv = w[0];
  var minv = w[0];
  var maxi = 0;
  var mini = 0;
  var n = w.length;
  for(var i=1;i&lt;n;i++) {
    if(w[i] &gt; maxv) { maxv = w[i]; maxi = i; }
    if(w[i] &lt; minv) { minv = w[i]; mini = i; }
  }
  return {maxi: maxi, maxv: maxv, mini: mini, minv: minv, dv:maxv-minv};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.randf" id="apidoc.element.convnetjs.randf">
        function <span class="apidocSignatureSpan">convnetjs.</span>randf
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">randf = function (a, b) { return Math.random()*(b-a)+a; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // we are abstracting this away because in future we may want to
  // do more sophisticated things. For example some actions could be more
  // or less likely at "rest"/default state.
  if(this.random_action_distribution.length === 0) {
    return convnetjs.randi(0, this.num_actions);
  } else {
    // okay, lets do some fancier sampling:
    var p = convnetjs.<span class="apidocCodeKeywordSpan">randf</span>(0, 1.0);
    var cumprob = 0.0;
    for(var k=0;k&lt;this.num_actions;k++) {
      cumprob += this.random_action_distribution[k];
      if(p &lt; cumprob) { return k; }
    }
  }
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.randi" id="apidoc.element.convnetjs.randi">
        function <span class="apidocSignatureSpan">convnetjs.</span>randi
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">randi = function (a, b) { return Math.floor(Math.random()*(b-a)+a); }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// intended for use with data augmentation
// crop is the size of output
// dx,dy are offset wrt incoming volume, of the shift
// fliplr is boolean on whether we also want to flip left&lt;-&gt;right
var augment = function(V, crop, dx, dy, fliplr) {
  // note assumes square outputs of size crop x crop
  if(typeof(fliplr)==='undefined') var fliplr = false;
  if(typeof(dx)==='undefined') var dx = global.<span class="apidocCodeKeywordSpan">randi</span>(0, V.sx - crop);
  if(typeof(dy)==='undefined') var dy = global.randi(0, V.sy - crop);

  // randomly sample a crop in the input volume
  var W;
  if(crop !== V.sx || dx!==0 || dy!==0) {
    W = new Vol(crop, crop, V.depth, 0.0);
    for(var x=0;x&lt;crop;x++) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.randn" id="apidoc.element.convnetjs.randn">
        function <span class="apidocSignatureSpan">convnetjs.</span>randn
        <span class="apidocSignatureSpan">(mu, std)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">randn = function (mu, std){ return mu+gaussRandom()*std; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.dw = global.zeros(n);
  if(typeof c === 'undefined') {
    // weight normalization is done to equalize the output
    // variance of every neuron, otherwise neurons with a lot
    // of incoming connections have outputs of larger variance
    var scale = Math.sqrt(1.0/(sx*sy*depth));
    for(var i=0;i&lt;n;i++) {
      this.w[i] = global.<span class="apidocCodeKeywordSpan">randn</span>(0.0, scale);
    }
  } else {
    for(var i=0;i&lt;n;i++) {
      this.w[i] = c;
    }
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.randperm" id="apidoc.element.convnetjs.randperm">
        function <span class="apidocSignatureSpan">convnetjs.</span>randperm
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">randperm = function (n) {
  var i = n,
      j = 0,
      temp;
  var array = [];
  for(var q=0;q&lt;n;q++)array[q]=q;
  while (i--) {
      j = Math.floor(Math.random() * (i+1));
      temp = array[i];
      array[i] = array[j];
      array[j] = temp;
  }
  return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.weightedSample" id="apidoc.element.convnetjs.weightedSample">
        function <span class="apidocSignatureSpan">convnetjs.</span>weightedSample
        <span class="apidocSignatureSpan">(lst, probs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">weightedSample = function (lst, probs) {
  var p = randf(0, 1.0);
  var cumprob = 0.0;
  for(var k=0,n=lst.length;k&lt;n;k++) {
    cumprob += probs[k];
    if(p &lt; cumprob) { return lst[k]; }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.zeros" id="apidoc.element.convnetjs.zeros">
        function <span class="apidocSignatureSpan">convnetjs.</span>zeros
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zeros = function (n) {
  if(typeof(n)==='undefined' || isNaN(n)) { return []; }
  if(typeof ArrayBuffer === 'undefined') {
    // lacking browser support
    var arr = new Array(n);
    for(var i=0;i&lt;n;i++) { arr[i]= 0; }
    return arr;
  } else {
    return new Float64Array(n);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(Object.prototype.toString.call(sx) === '[object Array]') {
  // we were given a list in sx, assume 1D volume and fill it up
  this.sx = 1;
  this.sy = 1;
  this.depth = sx.length;
  // we have to do the following copy because we want to use
  // fast typed arrays, not an ordinary javascript array
  this.w = global.<span class="apidocCodeKeywordSpan">zeros</span>(this.depth);
  this.dw = global.zeros(this.depth);
  for(var i=0;i&lt;this.depth;i++) {
    this.w[i] = sx[i];
  }
} else {
  // we were given dimensions of the vol
  this.sx = sx;
...</pre></li>
    </ul>








































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.ConvLayer" id="apidoc.module.convnetjs.ConvLayer">module convnetjs.ConvLayer</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.ConvLayer.ConvLayer" id="apidoc.element.convnetjs.ConvLayer.ConvLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>ConvLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ConvLayer = function (opt) {
  var opt = opt || {};

  // required
  this.out_depth = opt.filters;
  this.sx = opt.sx; // filter size. Should be odd if possible, it's cleaner.
  this.in_depth = opt.in_depth;
  this.in_sx = opt.in_sx;
  this.in_sy = opt.in_sy;

  // optional
  this.sy = typeof opt.sy !== 'undefined' ? opt.sy : this.sx;
  this.stride = typeof opt.stride !== 'undefined' ? opt.stride : 1; // stride at which we apply filters to input volume
  this.pad = typeof opt.pad !== 'undefined' ? opt.pad : 0; // amount of 0 padding to add around borders of input volume
  this.l1_decay_mul = typeof opt.l1_decay_mul !== 'undefined' ? opt.l1_decay_mul : 0.0;
  this.l2_decay_mul = typeof opt.l2_decay_mul !== 'undefined' ? opt.l2_decay_mul : 1.0;

  // computed
  // note we are doing floor, so if the strided convolution of the filter doesnt fit into the input
  // volume exactly, the output volume will be trimmed and not contain the (incomplete) computed
  // final application.
  this.out_sx = Math.floor((this.in_sx + this.pad * 2 - this.sx) / this.stride + 1);
  this.out_sy = Math.floor((this.in_sy + this.pad * 2 - this.sy) / this.stride + 1);
  this.layer_type = 'conv';

  // initializations
  var bias = typeof opt.bias_pref !== 'undefined' ? opt.bias_pref : 0.0;
  this.filters = [];
  for(var i=0;i&lt;this.out_depth;i++) { this.filters.push(new Vol(this.sx, this.sy, this.in_depth)); }
  this.biases = new Vol(1, 1, this.out_depth, bias);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        switch(def.type) {
case 'fc': this.layers.push(new global.FullyConnLayer(def)); break;
case 'lrn': this.layers.push(new global.LocalResponseNormalizationLayer(def)); break;
case 'dropout': this.layers.push(new global.DropoutLayer(def)); break;
case 'input': this.layers.push(new global.InputLayer(def)); break;
case 'softmax': this.layers.push(new global.SoftmaxLayer(def)); break;
case 'regression': this.layers.push(new global.RegressionLayer(def)); break;
case 'conv': this.layers.push(new global.<span class="apidocCodeKeywordSpan">ConvLayer</span>(def)); break;
case 'pool': this.layers.push(new global.PoolLayer(def)); break;
case 'relu': this.layers.push(new global.ReluLayer(def)); break;
case 'sigmoid': this.layers.push(new global.SigmoidLayer(def)); break;
case 'tanh': this.layers.push(new global.TanhLayer(def)); break;
case 'maxout': this.layers.push(new global.MaxoutLayer(def)); break;
case 'quadtransform': this.layers.push(new global.QuadTransformLayer(def)); break;
case 'svm': this.layers.push(new global.SVMLayer(def)); break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.ConvLayer.prototype" id="apidoc.module.convnetjs.ConvLayer.prototype">module convnetjs.ConvLayer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.ConvLayer.prototype.backward" id="apidoc.element.convnetjs.ConvLayer.prototype.backward">
        function <span class="apidocSignatureSpan">convnetjs.ConvLayer.prototype.</span>backward
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">backward = function () {

  // compute gradient wrt weights, biases and input data
  var V = this.in_act;
  V.dw = global.zeros(V.w.length); // zero out gradient wrt bottom data, we're about to fill it
  for(var d=0;d&lt;this.out_depth;d++) {
    var f = this.filters[d];
    var x = -this.pad;
    var y = -this.pad;
    for(var ax=0; ax&lt;this.out_sx; x+=this.stride,ax++) {
      y = -this.pad;
      for(var ay=0; ay&lt;this.out_sy; y+=this.stride,ay++) {
        // convolve and add up the gradients.
        // could be more efficient, going for correctness first
        var chain_grad = this.out_act.get_grad(ax,ay,d); // gradient from above, from chain rule
        for(var fx=0;fx&lt;f.sx;fx++) {
          for(var fy=0;fy&lt;f.sy;fy++) {
            for(var fd=0;fd&lt;f.depth;fd++) {
              var oy = y+fy;
              var ox = x+fx;
              if(oy&gt;=0 &amp;&amp; oy&lt;V.sy &amp;&amp; ox&gt;=0 &amp;&amp; ox&lt;V.sx) {
                // forward prop calculated: a += f.get(fx, fy, fd) * V.get(ox, oy, fd);
                //f.add_grad(fx, fy, fd, V.get(ox, oy, fd) * chain_grad);
                //V.add_grad(ox, oy, fd, f.get(fx, fy, fd) * chain_grad);

                // avoid function call overhead and use Vols directly for efficiency
                var ix1 = ((V.sx * oy)+ox)*V.depth+fd;
                var ix2 = ((f.sx * fy)+fx)*f.depth+fd;
                f.dw[ix2] += V.w[ix1]*chain_grad;
                V.dw[ix1] += f.w[ix2]*chain_grad;
              }
            }
          }
        }
        this.biases.dw[d] += chain_grad;
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return act;
},

// backprop: compute gradients wrt all parameters
backward: function(y) {
  var N = this.layers.length;
  var loss = this.layers[N-1].<span class="apidocCodeKeywordSpan">backward</span>(y); // last layer assumed softmax
  for(var i=N-2;i&gt;=0;i--) { // first layer assumed input
    this.layers[i].backward();
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.ConvLayer.prototype.forward" id="apidoc.element.convnetjs.ConvLayer.prototype.forward">
        function <span class="apidocSignatureSpan">convnetjs.ConvLayer.prototype.</span>forward
        <span class="apidocSignatureSpan">(V, is_training)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forward = function (V, is_training) {
  this.in_act = V;

  var A = new Vol(this.out_sx, this.out_sy, this.out_depth, 0.0);
  for(var d=0;d&lt;this.out_depth;d++) {
    var f = this.filters[d];
    var x = -this.pad;
    var y = -this.pad;
    for(var ax=0; ax&lt;this.out_sx; x+=this.stride,ax++) {
      y = -this.pad;
      for(var ay=0; ay&lt;this.out_sy; y+=this.stride,ay++) {

        // convolve centered at this particular location
        // could be bit more efficient, going for correctness first
        var a = 0.0;
        for(var fx=0;fx&lt;f.sx;fx++) {
          for(var fy=0;fy&lt;f.sy;fy++) {
            for(var fd=0;fd&lt;f.depth;fd++) {
              var oy = y+fy; // coordinates in the original input array coordinates
              var ox = x+fx;
              if(oy&gt;=0 &amp;&amp; oy&lt;V.sy &amp;&amp; ox&gt;=0 &amp;&amp; ox&lt;V.sx) {
                //a += f.get(fx, fy, fd) * V.get(ox, oy, fd);
                // avoid function call overhead for efficiency, compromise modularity :(
                a += f.w[((f.sx * fy)+fx)*f.depth+fd] * V.w[((V.sx * oy)+ox)*V.depth+fd];
              }
            }
          }
        }
        a += this.biases.w[d];
        A.set(ax, ay, d, a);
      }
    }
  }
  this.out_act = A;
  return this.out_act;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
},

// forward prop the network. A trainer will pass in is_training = true
forward: function(V, is_training) {
  if(typeof(is_training)==='undefined') is_training = false;
  var act = this.layers[0].<span class="apidocCodeKeywordSpan">forward</span>(V, is_training);
  for(var i=1;i&lt;this.layers.length;i++) {
    act = this.layers[i].forward(act, is_training);
  }
  return act;
},

// backprop: compute gradients wrt all parameters
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.ConvLayer.prototype.fromJSON" id="apidoc.element.convnetjs.ConvLayer.prototype.fromJSON">
        function <span class="apidocSignatureSpan">convnetjs.ConvLayer.prototype.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
  this.out_sy = json.out_sy;
  this.layer_type = json.layer_type;
  this.sx = json.sx; // filter size in x, y dims
  this.sy = json.sy;
  this.stride = json.stride;
  this.in_depth = json.in_depth; // depth of input volume
  this.filters = [];
  this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;
  this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;
  this.pad = typeof json.pad !== 'undefined' ? json.pad : 0;
  for(var i=0;i&lt;json.filters.length;i++) {
    var v = new Vol(0,0,0,0);
    v.fromJSON(json.filters[i]);
    this.filters.push(v);
  }
  this.biases = new Vol(0,0,0,0);
  this.biases.fromJSON(json.biases);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.in_depth = json.in_depth; // depth of input volume
    this.filters = [];
    this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;
    this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;
    this.pad = typeof json.pad !== 'undefined' ? json.pad : 0;
    for(var i=0;i&lt;json.filters.length;i++) {
      var v = new Vol(0,0,0,0);
      v.<span class="apidocCodeKeywordSpan">fromJSON</span>(json.filters[i]);
      this.filters.push(v);
    }
    this.biases = new Vol(0,0,0,0);
    this.biases.fromJSON(json.biases);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.ConvLayer.prototype.getParamsAndGrads" id="apidoc.element.convnetjs.ConvLayer.prototype.getParamsAndGrads">
        function <span class="apidocSignatureSpan">convnetjs.ConvLayer.prototype.</span>getParamsAndGrads
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getParamsAndGrads = function () {
  var response = [];
  for(var i=0;i&lt;this.out_depth;i++) {
    response.push({params: this.filters[i].w, grads: this.filters[i].dw, l2_decay_mul: this.l2_decay_mul, l1_decay_mul: this.l1_decay_mul
});
  }
  response.push({params: this.biases.w, grads: this.biases.dw, l1_decay_mul: 0.0, l2_decay_mul: 0.0});
  return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
  var response = [];
  for(var i=0;i&lt;this.layers.length;i++) {
    var layer_reponse = this.layers[i].<span class="apidocCodeKeywordSpan">getParamsAndGrads</span>();
    for(var j=0;j&lt;layer_reponse.length;j++) {
      response.push(layer_reponse[j]);
    }
  }
  return response;
},
getPrediction: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.ConvLayer.prototype.toJSON" id="apidoc.element.convnetjs.ConvLayer.prototype.toJSON">
        function <span class="apidocSignatureSpan">convnetjs.ConvLayer.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  var json = {};
  json.sx = this.sx; // filter size in x, y dims
  json.sy = this.sy;
  json.stride = this.stride;
  json.in_depth = this.in_depth;
  json.out_depth = this.out_depth;
  json.out_sx = this.out_sx;
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  json.l1_decay_mul = this.l1_decay_mul;
  json.l2_decay_mul = this.l2_decay_mul;
  json.pad = this.pad;
  json.filters = [];
  for(var i=0;i&lt;this.filters.length;i++) {
    json.filters.push(this.filters[i].toJSON());
  }
  json.biases = this.biases.toJSON();
  return json;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  json.l1_decay_mul = this.l1_decay_mul;
  json.l2_decay_mul = this.l2_decay_mul;
  json.pad = this.pad;
  json.filters = [];
  for(var i=0;i&lt;this.filters.length;i++) {
    json.filters.push(this.filters[i].<span class="apidocCodeKeywordSpan">toJSON</span>());
  }
  json.biases = this.biases.toJSON();
  return json;
},
fromJSON: function(json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.DropoutLayer" id="apidoc.module.convnetjs.DropoutLayer">module convnetjs.DropoutLayer</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.DropoutLayer.DropoutLayer" id="apidoc.element.convnetjs.DropoutLayer.DropoutLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>DropoutLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">DropoutLayer = function (opt) {
  var opt = opt || {};

  // computed
  this.out_sx = opt.in_sx;
  this.out_sy = opt.in_sy;
  this.out_depth = opt.in_depth;
  this.layer_type = 'dropout';
  this.drop_prob = typeof opt.drop_prob !== 'undefined' ? opt.drop_prob : 0.5;
  this.dropped = global.zeros(this.out_sx*this.out_sy*this.out_depth);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  def.in_sy = prev.out_sy;
  def.in_depth = prev.out_depth;
}

switch(def.type) {
  case 'fc': this.layers.push(new global.FullyConnLayer(def)); break;
  case 'lrn': this.layers.push(new global.LocalResponseNormalizationLayer(def)); break;
  case 'dropout': this.layers.push(new global.<span class="apidocCodeKeywordSpan">DropoutLayer</span>(def)); break;
  case 'input': this.layers.push(new global.InputLayer(def)); break;
  case 'softmax': this.layers.push(new global.SoftmaxLayer(def)); break;
  case 'regression': this.layers.push(new global.RegressionLayer(def)); break;
  case 'conv': this.layers.push(new global.ConvLayer(def)); break;
  case 'pool': this.layers.push(new global.PoolLayer(def)); break;
  case 'relu': this.layers.push(new global.ReluLayer(def)); break;
  case 'sigmoid': this.layers.push(new global.SigmoidLayer(def)); break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.DropoutLayer.prototype" id="apidoc.module.convnetjs.DropoutLayer.prototype">module convnetjs.DropoutLayer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.DropoutLayer.prototype.backward" id="apidoc.element.convnetjs.DropoutLayer.prototype.backward">
        function <span class="apidocSignatureSpan">convnetjs.DropoutLayer.prototype.</span>backward
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">backward = function () {
  var V = this.in_act; // we need to set dw of this
  var chain_grad = this.out_act;
  var N = V.w.length;
  V.dw = global.zeros(N); // zero out gradient wrt data
  for(var i=0;i&lt;N;i++) {
    if(!(this.dropped[i])) {
      V.dw[i] = chain_grad.dw[i]; // copy over the gradient
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return act;
},

// backprop: compute gradients wrt all parameters
backward: function(y) {
  var N = this.layers.length;
  var loss = this.layers[N-1].<span class="apidocCodeKeywordSpan">backward</span>(y); // last layer assumed softmax
  for(var i=N-2;i&gt;=0;i--) { // first layer assumed input
    this.layers[i].backward();
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.DropoutLayer.prototype.forward" id="apidoc.element.convnetjs.DropoutLayer.prototype.forward">
        function <span class="apidocSignatureSpan">convnetjs.DropoutLayer.prototype.</span>forward
        <span class="apidocSignatureSpan">(V, is_training)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forward = function (V, is_training) {
  this.in_act = V;
  if(typeof(is_training)==='undefined') { is_training = false; } // default is prediction mode
  var V2 = V.clone();
  var N = V.w.length;
  if(is_training) {
    // do dropout
    for(var i=0;i&lt;N;i++) {
      if(Math.random()&lt;this.drop_prob) { V2.w[i]=0; this.dropped[i] = true; } // drop!
      else {this.dropped[i] = false;}
    }
  } else {
    // scale the activations during prediction
    for(var i=0;i&lt;N;i++) { V2.w[i]*=this.drop_prob; }
  }
  this.out_act = V2;
  return this.out_act; // dummy identity function for now
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
},

// forward prop the network. A trainer will pass in is_training = true
forward: function(V, is_training) {
  if(typeof(is_training)==='undefined') is_training = false;
  var act = this.layers[0].<span class="apidocCodeKeywordSpan">forward</span>(V, is_training);
  for(var i=1;i&lt;this.layers.length;i++) {
    act = this.layers[i].forward(act, is_training);
  }
  return act;
},

// backprop: compute gradients wrt all parameters
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.DropoutLayer.prototype.fromJSON" id="apidoc.element.convnetjs.DropoutLayer.prototype.fromJSON">
        function <span class="apidocSignatureSpan">convnetjs.DropoutLayer.prototype.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
  this.out_sy = json.out_sy;
  this.layer_type = json.layer_type;
  this.drop_prob = json.drop_prob;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.in_depth = json.in_depth; // depth of input volume
    this.filters = [];
    this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;
    this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;
    this.pad = typeof json.pad !== 'undefined' ? json.pad : 0;
    for(var i=0;i&lt;json.filters.length;i++) {
      var v = new Vol(0,0,0,0);
      v.<span class="apidocCodeKeywordSpan">fromJSON</span>(json.filters[i]);
      this.filters.push(v);
    }
    this.biases = new Vol(0,0,0,0);
    this.biases.fromJSON(json.biases);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.DropoutLayer.prototype.getParamsAndGrads" id="apidoc.element.convnetjs.DropoutLayer.prototype.getParamsAndGrads">
        function <span class="apidocSignatureSpan">convnetjs.DropoutLayer.prototype.</span>getParamsAndGrads
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getParamsAndGrads = function () {
  return [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
  var response = [];
  for(var i=0;i&lt;this.layers.length;i++) {
    var layer_reponse = this.layers[i].<span class="apidocCodeKeywordSpan">getParamsAndGrads</span>();
    for(var j=0;j&lt;layer_reponse.length;j++) {
      response.push(layer_reponse[j]);
    }
  }
  return response;
},
getPrediction: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.DropoutLayer.prototype.toJSON" id="apidoc.element.convnetjs.DropoutLayer.prototype.toJSON">
        function <span class="apidocSignatureSpan">convnetjs.DropoutLayer.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  var json = {};
  json.out_depth = this.out_depth;
  json.out_sx = this.out_sx;
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  json.drop_prob = this.drop_prob;
  return json;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  json.l1_decay_mul = this.l1_decay_mul;
  json.l2_decay_mul = this.l2_decay_mul;
  json.pad = this.pad;
  json.filters = [];
  for(var i=0;i&lt;this.filters.length;i++) {
    json.filters.push(this.filters[i].<span class="apidocCodeKeywordSpan">toJSON</span>());
  }
  json.biases = this.biases.toJSON();
  return json;
},
fromJSON: function(json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.FullyConnLayer" id="apidoc.module.convnetjs.FullyConnLayer">module convnetjs.FullyConnLayer</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.FullyConnLayer.FullyConnLayer" id="apidoc.element.convnetjs.FullyConnLayer.FullyConnLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>FullyConnLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">FullyConnLayer = function (opt) {
  var opt = opt || {};

  // required
  // ok fine we will allow 'filters' as the word as well
  this.out_depth = typeof opt.num_neurons !== 'undefined' ? opt.num_neurons : opt.filters;

  // optional
  this.l1_decay_mul = typeof opt.l1_decay_mul !== 'undefined' ? opt.l1_decay_mul : 0.0;
  this.l2_decay_mul = typeof opt.l2_decay_mul !== 'undefined' ? opt.l2_decay_mul : 1.0;

  // computed
  this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;
  this.out_sx = 1;
  this.out_sy = 1;
  this.layer_type = 'fc';

  // initializations
  var bias = typeof opt.bias_pref !== 'undefined' ? opt.bias_pref : 0.0;
  this.filters = [];
  for(var i=0;i&lt;this.out_depth ;i++) { this.filters.push(new Vol(1, 1, this.num_inputs)); }
  this.biases = new Vol(1, 1, this.out_depth, bias);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var prev = this.layers[i-1];
  def.in_sx = prev.out_sx;
  def.in_sy = prev.out_sy;
  def.in_depth = prev.out_depth;
}

switch(def.type) {
  case 'fc': this.layers.push(new global.<span class="apidocCodeKeywordSpan">FullyConnLayer</span>(def)); break;
  case 'lrn': this.layers.push(new global.LocalResponseNormalizationLayer(def)); break;
  case 'dropout': this.layers.push(new global.DropoutLayer(def)); break;
  case 'input': this.layers.push(new global.InputLayer(def)); break;
  case 'softmax': this.layers.push(new global.SoftmaxLayer(def)); break;
  case 'regression': this.layers.push(new global.RegressionLayer(def)); break;
  case 'conv': this.layers.push(new global.ConvLayer(def)); break;
  case 'pool': this.layers.push(new global.PoolLayer(def)); break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.FullyConnLayer.prototype" id="apidoc.module.convnetjs.FullyConnLayer.prototype">module convnetjs.FullyConnLayer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.FullyConnLayer.prototype.backward" id="apidoc.element.convnetjs.FullyConnLayer.prototype.backward">
        function <span class="apidocSignatureSpan">convnetjs.FullyConnLayer.prototype.</span>backward
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">backward = function () {
  var V = this.in_act;
  V.dw = global.zeros(V.w.length); // zero out the gradient in input Vol

  // compute gradient wrt weights and data
  for(var i=0;i&lt;this.out_depth;i++) {
    var tfi = this.filters[i];
    var chain_grad = this.out_act.dw[i];
    for(var d=0;d&lt;this.num_inputs;d++) {
      V.dw[d] += tfi.w[d]*chain_grad; // grad wrt input data
      tfi.dw[d] += V.w[d]*chain_grad; // grad wrt params
    }
    this.biases.dw[i] += chain_grad;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return act;
},

// backprop: compute gradients wrt all parameters
backward: function(y) {
  var N = this.layers.length;
  var loss = this.layers[N-1].<span class="apidocCodeKeywordSpan">backward</span>(y); // last layer assumed softmax
  for(var i=N-2;i&gt;=0;i--) { // first layer assumed input
    this.layers[i].backward();
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.FullyConnLayer.prototype.forward" id="apidoc.element.convnetjs.FullyConnLayer.prototype.forward">
        function <span class="apidocSignatureSpan">convnetjs.FullyConnLayer.prototype.</span>forward
        <span class="apidocSignatureSpan">(V, is_training)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forward = function (V, is_training) {
  this.in_act = V;
  var A = new Vol(1, 1, this.out_depth, 0.0);
  var Vw = V.w;
  for(var i=0;i&lt;this.out_depth;i++) {
    var a = 0.0;
    var wi = this.filters[i].w;
    for(var d=0;d&lt;this.num_inputs;d++) {
      a += Vw[d] * wi[d]; // for efficiency use Vols directly for now
    }
    a += this.biases.w[i];
    A.w[i] = a;
  }
  this.out_act = A;
  return this.out_act;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
},

// forward prop the network. A trainer will pass in is_training = true
forward: function(V, is_training) {
  if(typeof(is_training)==='undefined') is_training = false;
  var act = this.layers[0].<span class="apidocCodeKeywordSpan">forward</span>(V, is_training);
  for(var i=1;i&lt;this.layers.length;i++) {
    act = this.layers[i].forward(act, is_training);
  }
  return act;
},

// backprop: compute gradients wrt all parameters
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.FullyConnLayer.prototype.fromJSON" id="apidoc.element.convnetjs.FullyConnLayer.prototype.fromJSON">
        function <span class="apidocSignatureSpan">convnetjs.FullyConnLayer.prototype.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
  this.out_sy = json.out_sy;
  this.layer_type = json.layer_type;
  this.num_inputs = json.num_inputs;
  this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;
  this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;
  this.filters = [];
  for(var i=0;i&lt;json.filters.length;i++) {
    var v = new Vol(0,0,0,0);
    v.fromJSON(json.filters[i]);
    this.filters.push(v);
  }
  this.biases = new Vol(0,0,0,0);
  this.biases.fromJSON(json.biases);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.in_depth = json.in_depth; // depth of input volume
    this.filters = [];
    this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;
    this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;
    this.pad = typeof json.pad !== 'undefined' ? json.pad : 0;
    for(var i=0;i&lt;json.filters.length;i++) {
      var v = new Vol(0,0,0,0);
      v.<span class="apidocCodeKeywordSpan">fromJSON</span>(json.filters[i]);
      this.filters.push(v);
    }
    this.biases = new Vol(0,0,0,0);
    this.biases.fromJSON(json.biases);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.FullyConnLayer.prototype.getParamsAndGrads" id="apidoc.element.convnetjs.FullyConnLayer.prototype.getParamsAndGrads">
        function <span class="apidocSignatureSpan">convnetjs.FullyConnLayer.prototype.</span>getParamsAndGrads
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getParamsAndGrads = function () {
  var response = [];
  for(var i=0;i&lt;this.out_depth;i++) {
    response.push({params: this.filters[i].w, grads: this.filters[i].dw, l1_decay_mul: this.l1_decay_mul, l2_decay_mul: this.l2_decay_mul
});
  }
  response.push({params: this.biases.w, grads: this.biases.dw, l1_decay_mul: 0.0, l2_decay_mul: 0.0});
  return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
  var response = [];
  for(var i=0;i&lt;this.layers.length;i++) {
    var layer_reponse = this.layers[i].<span class="apidocCodeKeywordSpan">getParamsAndGrads</span>();
    for(var j=0;j&lt;layer_reponse.length;j++) {
      response.push(layer_reponse[j]);
    }
  }
  return response;
},
getPrediction: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.FullyConnLayer.prototype.toJSON" id="apidoc.element.convnetjs.FullyConnLayer.prototype.toJSON">
        function <span class="apidocSignatureSpan">convnetjs.FullyConnLayer.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  var json = {};
  json.out_depth = this.out_depth;
  json.out_sx = this.out_sx;
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  json.num_inputs = this.num_inputs;
  json.l1_decay_mul = this.l1_decay_mul;
  json.l2_decay_mul = this.l2_decay_mul;
  json.filters = [];
  for(var i=0;i&lt;this.filters.length;i++) {
    json.filters.push(this.filters[i].toJSON());
  }
  json.biases = this.biases.toJSON();
  return json;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  json.l1_decay_mul = this.l1_decay_mul;
  json.l2_decay_mul = this.l2_decay_mul;
  json.pad = this.pad;
  json.filters = [];
  for(var i=0;i&lt;this.filters.length;i++) {
    json.filters.push(this.filters[i].<span class="apidocCodeKeywordSpan">toJSON</span>());
  }
  json.biases = this.biases.toJSON();
  return json;
},
fromJSON: function(json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.InputLayer" id="apidoc.module.convnetjs.InputLayer">module convnetjs.InputLayer</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.InputLayer.InputLayer" id="apidoc.element.convnetjs.InputLayer.InputLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>InputLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">InputLayer = function (opt) {
  var opt = opt || {};

  // this is a bit silly but lets allow people to specify either ins or outs
  this.out_sx = typeof opt.out_sx !== 'undefined' ? opt.out_sx : opt.in_sx;
  this.out_sy = typeof opt.out_sy !== 'undefined' ? opt.out_sy : opt.in_sy;
  this.out_depth = typeof opt.out_depth !== 'undefined' ? opt.out_depth : opt.in_depth;
  this.layer_type = 'input';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  def.in_depth = prev.out_depth;
}

switch(def.type) {
  case 'fc': this.layers.push(new global.FullyConnLayer(def)); break;
  case 'lrn': this.layers.push(new global.LocalResponseNormalizationLayer(def)); break;
  case 'dropout': this.layers.push(new global.DropoutLayer(def)); break;
  case 'input': this.layers.push(new global.<span class="apidocCodeKeywordSpan">InputLayer</span>(def)); break;
  case 'softmax': this.layers.push(new global.SoftmaxLayer(def)); break;
  case 'regression': this.layers.push(new global.RegressionLayer(def)); break;
  case 'conv': this.layers.push(new global.ConvLayer(def)); break;
  case 'pool': this.layers.push(new global.PoolLayer(def)); break;
  case 'relu': this.layers.push(new global.ReluLayer(def)); break;
  case 'sigmoid': this.layers.push(new global.SigmoidLayer(def)); break;
  case 'tanh': this.layers.push(new global.TanhLayer(def)); break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.InputLayer.prototype" id="apidoc.module.convnetjs.InputLayer.prototype">module convnetjs.InputLayer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.InputLayer.prototype.backward" id="apidoc.element.convnetjs.InputLayer.prototype.backward">
        function <span class="apidocSignatureSpan">convnetjs.InputLayer.prototype.</span>backward
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">backward = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return act;
},

// backprop: compute gradients wrt all parameters
backward: function(y) {
  var N = this.layers.length;
  var loss = this.layers[N-1].<span class="apidocCodeKeywordSpan">backward</span>(y); // last layer assumed softmax
  for(var i=N-2;i&gt;=0;i--) { // first layer assumed input
    this.layers[i].backward();
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.InputLayer.prototype.forward" id="apidoc.element.convnetjs.InputLayer.prototype.forward">
        function <span class="apidocSignatureSpan">convnetjs.InputLayer.prototype.</span>forward
        <span class="apidocSignatureSpan">(V, is_training)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forward = function (V, is_training) {
  this.in_act = V;
  this.out_act = V;
  return this.out_act; // dummy identity function for now
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
},

// forward prop the network. A trainer will pass in is_training = true
forward: function(V, is_training) {
  if(typeof(is_training)==='undefined') is_training = false;
  var act = this.layers[0].<span class="apidocCodeKeywordSpan">forward</span>(V, is_training);
  for(var i=1;i&lt;this.layers.length;i++) {
    act = this.layers[i].forward(act, is_training);
  }
  return act;
},

// backprop: compute gradients wrt all parameters
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.InputLayer.prototype.fromJSON" id="apidoc.element.convnetjs.InputLayer.prototype.fromJSON">
        function <span class="apidocSignatureSpan">convnetjs.InputLayer.prototype.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
  this.out_sy = json.out_sy;
  this.layer_type = json.layer_type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.in_depth = json.in_depth; // depth of input volume
    this.filters = [];
    this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;
    this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;
    this.pad = typeof json.pad !== 'undefined' ? json.pad : 0;
    for(var i=0;i&lt;json.filters.length;i++) {
      var v = new Vol(0,0,0,0);
      v.<span class="apidocCodeKeywordSpan">fromJSON</span>(json.filters[i]);
      this.filters.push(v);
    }
    this.biases = new Vol(0,0,0,0);
    this.biases.fromJSON(json.biases);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.InputLayer.prototype.getParamsAndGrads" id="apidoc.element.convnetjs.InputLayer.prototype.getParamsAndGrads">
        function <span class="apidocSignatureSpan">convnetjs.InputLayer.prototype.</span>getParamsAndGrads
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getParamsAndGrads = function () {
  return [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
  var response = [];
  for(var i=0;i&lt;this.layers.length;i++) {
    var layer_reponse = this.layers[i].<span class="apidocCodeKeywordSpan">getParamsAndGrads</span>();
    for(var j=0;j&lt;layer_reponse.length;j++) {
      response.push(layer_reponse[j]);
    }
  }
  return response;
},
getPrediction: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.InputLayer.prototype.toJSON" id="apidoc.element.convnetjs.InputLayer.prototype.toJSON">
        function <span class="apidocSignatureSpan">convnetjs.InputLayer.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  var json = {};
  json.out_depth = this.out_depth;
  json.out_sx = this.out_sx;
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  return json;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  json.l1_decay_mul = this.l1_decay_mul;
  json.l2_decay_mul = this.l2_decay_mul;
  json.pad = this.pad;
  json.filters = [];
  for(var i=0;i&lt;this.filters.length;i++) {
    json.filters.push(this.filters[i].<span class="apidocCodeKeywordSpan">toJSON</span>());
  }
  json.biases = this.biases.toJSON();
  return json;
},
fromJSON: function(json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.LocalResponseNormalizationLayer" id="apidoc.module.convnetjs.LocalResponseNormalizationLayer">module convnetjs.LocalResponseNormalizationLayer</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.LocalResponseNormalizationLayer.LocalResponseNormalizationLayer" id="apidoc.element.convnetjs.LocalResponseNormalizationLayer.LocalResponseNormalizationLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>LocalResponseNormalizationLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">LocalResponseNormalizationLayer = function (opt) {
  var opt = opt || {};

  // required
  this.k = opt.k;
  this.n = opt.n;
  this.alpha = opt.alpha;
  this.beta = opt.beta;

  // computed
  this.out_sx = opt.in_sx;
  this.out_sy = opt.in_sy;
  this.out_depth = opt.in_depth;
  this.layer_type = 'lrn';

  // checks
  if(this.n%2 === 0) { console.log('WARNING n should be odd for LRN layer'); }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  def.in_sx = prev.out_sx;
  def.in_sy = prev.out_sy;
  def.in_depth = prev.out_depth;
}

switch(def.type) {
  case 'fc': this.layers.push(new global.FullyConnLayer(def)); break;
  case 'lrn': this.layers.push(new global.<span class="apidocCodeKeywordSpan">LocalResponseNormalizationLayer</span>(def
)); break;
  case 'dropout': this.layers.push(new global.DropoutLayer(def)); break;
  case 'input': this.layers.push(new global.InputLayer(def)); break;
  case 'softmax': this.layers.push(new global.SoftmaxLayer(def)); break;
  case 'regression': this.layers.push(new global.RegressionLayer(def)); break;
  case 'conv': this.layers.push(new global.ConvLayer(def)); break;
  case 'pool': this.layers.push(new global.PoolLayer(def)); break;
  case 'relu': this.layers.push(new global.ReluLayer(def)); break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.LocalResponseNormalizationLayer.prototype" id="apidoc.module.convnetjs.LocalResponseNormalizationLayer.prototype">module convnetjs.LocalResponseNormalizationLayer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.LocalResponseNormalizationLayer.prototype.backward" id="apidoc.element.convnetjs.LocalResponseNormalizationLayer.prototype.backward">
        function <span class="apidocSignatureSpan">convnetjs.LocalResponseNormalizationLayer.prototype.</span>backward
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">backward = function () {
  // evaluate gradient wrt data
  var V = this.in_act; // we need to set dw of this
  V.dw = global.zeros(V.w.length); // zero out gradient wrt data
  var A = this.out_act; // computed in forward pass

  var n2 = Math.floor(this.n/2);
  for(var x=0;x&lt;V.sx;x++) {
    for(var y=0;y&lt;V.sy;y++) {
      for(var i=0;i&lt;V.depth;i++) {

        var chain_grad = this.out_act.get_grad(x,y,i);
        var S = this.S_cache_.get(x,y,i);
        var SB = Math.pow(S, this.beta);
        var SB2 = SB*SB;

        // normalize in a window of size n
        for(var j=Math.max(0,i-n2);j&lt;=Math.min(i+n2,V.depth-1);j++) {
          var aj = V.get(x,y,j);
          var g = -aj*this.beta*Math.pow(S,this.beta-1)*this.alpha/this.n*2*aj;
          if(j===i) g+= SB;
          g /= SB2;
          g *= chain_grad;
          V.add_grad(x,y,j,g);
        }

      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return act;
},

// backprop: compute gradients wrt all parameters
backward: function(y) {
  var N = this.layers.length;
  var loss = this.layers[N-1].<span class="apidocCodeKeywordSpan">backward</span>(y); // last layer assumed softmax
  for(var i=N-2;i&gt;=0;i--) { // first layer assumed input
    this.layers[i].backward();
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.LocalResponseNormalizationLayer.prototype.forward" id="apidoc.element.convnetjs.LocalResponseNormalizationLayer.prototype.forward">
        function <span class="apidocSignatureSpan">convnetjs.LocalResponseNormalizationLayer.prototype.</span>forward
        <span class="apidocSignatureSpan">(V, is_training)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forward = function (V, is_training) {
  this.in_act = V;

  var A = V.cloneAndZero();
  this.S_cache_ = V.cloneAndZero();
  var n2 = Math.floor(this.n/2);
  for(var x=0;x&lt;V.sx;x++) {
    for(var y=0;y&lt;V.sy;y++) {
      for(var i=0;i&lt;V.depth;i++) {

        var ai = V.get(x,y,i);

        // normalize in a window of size n
        var den = 0.0;
        for(var j=Math.max(0,i-n2);j&lt;=Math.min(i+n2,V.depth-1);j++) {
          var aa = V.get(x,y,j);
          den += aa*aa;
        }
        den *= this.alpha / this.n;
        den += this.k;
        this.S_cache_.set(x,y,i,den); // will be useful for backprop
        den = Math.pow(den, this.beta);
        A.set(x,y,i,ai/den);
      }
    }
  }

  this.out_act = A;
  return this.out_act; // dummy identity function for now
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
},

// forward prop the network. A trainer will pass in is_training = true
forward: function(V, is_training) {
  if(typeof(is_training)==='undefined') is_training = false;
  var act = this.layers[0].<span class="apidocCodeKeywordSpan">forward</span>(V, is_training);
  for(var i=1;i&lt;this.layers.length;i++) {
    act = this.layers[i].forward(act, is_training);
  }
  return act;
},

// backprop: compute gradients wrt all parameters
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.LocalResponseNormalizationLayer.prototype.fromJSON" id="apidoc.element.convnetjs.LocalResponseNormalizationLayer.prototype.fromJSON">
        function <span class="apidocSignatureSpan">convnetjs.LocalResponseNormalizationLayer.prototype.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  this.k = json.k;
  this.n = json.n;
  this.alpha = json.alpha; // normalize by size
  this.beta = json.beta;
  this.out_sx = json.out_sx;
  this.out_sy = json.out_sy;
  this.out_depth = json.out_depth;
  this.layer_type = json.layer_type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.in_depth = json.in_depth; // depth of input volume
    this.filters = [];
    this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;
    this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;
    this.pad = typeof json.pad !== 'undefined' ? json.pad : 0;
    for(var i=0;i&lt;json.filters.length;i++) {
      var v = new Vol(0,0,0,0);
      v.<span class="apidocCodeKeywordSpan">fromJSON</span>(json.filters[i]);
      this.filters.push(v);
    }
    this.biases = new Vol(0,0,0,0);
    this.biases.fromJSON(json.biases);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.LocalResponseNormalizationLayer.prototype.getParamsAndGrads" id="apidoc.element.convnetjs.LocalResponseNormalizationLayer.prototype.getParamsAndGrads">
        function <span class="apidocSignatureSpan">convnetjs.LocalResponseNormalizationLayer.prototype.</span>getParamsAndGrads
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getParamsAndGrads = function () { return []; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
  var response = [];
  for(var i=0;i&lt;this.layers.length;i++) {
    var layer_reponse = this.layers[i].<span class="apidocCodeKeywordSpan">getParamsAndGrads</span>();
    for(var j=0;j&lt;layer_reponse.length;j++) {
      response.push(layer_reponse[j]);
    }
  }
  return response;
},
getPrediction: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.LocalResponseNormalizationLayer.prototype.toJSON" id="apidoc.element.convnetjs.LocalResponseNormalizationLayer.prototype.toJSON">
        function <span class="apidocSignatureSpan">convnetjs.LocalResponseNormalizationLayer.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  var json = {};
  json.k = this.k;
  json.n = this.n;
  json.alpha = this.alpha; // normalize by size
  json.beta = this.beta;
  json.out_sx = this.out_sx;
  json.out_sy = this.out_sy;
  json.out_depth = this.out_depth;
  json.layer_type = this.layer_type;
  return json;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  json.l1_decay_mul = this.l1_decay_mul;
  json.l2_decay_mul = this.l2_decay_mul;
  json.pad = this.pad;
  json.filters = [];
  for(var i=0;i&lt;this.filters.length;i++) {
    json.filters.push(this.filters[i].<span class="apidocCodeKeywordSpan">toJSON</span>());
  }
  json.biases = this.biases.toJSON();
  return json;
},
fromJSON: function(json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.MagicNet" id="apidoc.module.convnetjs.MagicNet">module convnetjs.MagicNet</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.MagicNet.MagicNet" id="apidoc.element.convnetjs.MagicNet.MagicNet">
        function <span class="apidocSignatureSpan">convnetjs.</span>MagicNet
        <span class="apidocSignatureSpan">(data, labels, opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MagicNet = function (data, labels, opt) {
  var opt = opt || {};
  if(typeof data === 'undefined') { data = []; }
  if(typeof labels === 'undefined') { labels = []; }

  // required inputs
  this.data = data; // store these pointers to data
  this.labels = labels;

  // optional inputs
  this.train_ratio = getopt(opt, 'train_ratio', 0.7);
  this.num_folds = getopt(opt, 'num_folds', 10);
  this.num_candidates = getopt(opt, 'num_candidates', 50); // we evaluate several in parallel
  // how many epochs of data to train every network? for every fold?
  // higher values mean higher accuracy in final results, but more expensive
  this.num_epochs = getopt(opt, 'num_epochs', 50);
  // number of best models to average during prediction. Usually higher = better
  this.ensemble_size = getopt(opt, 'ensemble_size', 10);

  // candidate parameters
  this.batch_size_min = getopt(opt, 'batch_size_min', 10);
  this.batch_size_max = getopt(opt, 'batch_size_max', 300);
  this.l2_decay_min = getopt(opt, 'l2_decay_min', -4);
  this.l2_decay_max = getopt(opt, 'l2_decay_max', 2);
  this.learning_rate_min = getopt(opt, 'learning_rate_min', -4);
  this.learning_rate_max = getopt(opt, 'learning_rate_max', 0);
  this.momentum_min = getopt(opt, 'momentum_min', 0.9);
  this.momentum_max = getopt(opt, 'momentum_max', 0.9);
  this.neurons_min = getopt(opt, 'neurons_min', 5);
  this.neurons_max = getopt(opt, 'neurons_max', 30);

  // computed
  this.folds = []; // data fold indices, gets filled by sampleFolds()
  this.candidates = []; // candidate networks that are being currently evaluated
  this.evaluated_candidates = []; // history of all candidates that were fully evaluated on all folds
  this.unique_labels = arrUnique(labels);
  this.iter = 0; // iteration counter, goes from 0 -&gt; num_epochs * num_training_data
  this.foldix = 0; // index of active fold

  // callbacks
  this.finish_fold_callback = null;
  this.finish_batch_callback = null;

  // initializations
  if(this.data.length &gt; 0) {
    this.sampleFolds();
    this.sampleCandidates();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.MagicNet.prototype" id="apidoc.module.convnetjs.MagicNet.prototype">module convnetjs.MagicNet.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.MagicNet.prototype.evalValErrors" id="apidoc.element.convnetjs.MagicNet.prototype.evalValErrors">
        function <span class="apidocSignatureSpan">convnetjs.MagicNet.prototype.</span>evalValErrors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">evalValErrors = function () {
  // evaluate candidates on validation data and return performance of current networks
  // as simple list
  var vals = [];
  var fold = this.folds[this.foldix]; // active fold
  for(var k=0;k&lt;this.candidates.length;k++) {
    var net = this.candidates[k].net;
    var v = 0.0;
    for(var q=0;q&lt;fold.test_ix.length;q++) {
      var x = this.data[fold.test_ix[q]];
      var l = this.labels[fold.test_ix[q]];
      net.forward(x);
      var yhat = net.getPrediction();
      v += (yhat === l ? 1.0 : 0.0); // 0 1 loss
    }
    v /= fold.test_ix.length; // normalize
    vals.push(v);
  }
  return vals;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// process consequences: sample new folds, or candidates
var lastiter = this.num_epochs * fold.train_ix.length;
if(this.iter &gt;= lastiter) {
  // finished evaluation of this fold. Get final validation
  // accuracies, record them, and go on to next fold.
  var val_acc = this.<span class="apidocCodeKeywordSpan">evalValErrors</span>();
  for(var k=0;k&lt;this.candidates.length;k++) {
    var c = this.candidates[k];
    c.acc.push(val_acc[k]);
    c.accv += val_acc[k];
  }
  this.iter = 0; // reset step number
  this.foldix++; // increment fold
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.MagicNet.prototype.fromJSON" id="apidoc.element.convnetjs.MagicNet.prototype.fromJSON">
        function <span class="apidocSignatureSpan">convnetjs.MagicNet.prototype.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  this.ensemble_size = json.nets.length;
  this.evaluated_candidates = [];
  for(var i=0;i&lt;this.ensemble_size;i++) {
    var net = new Net();
    net.fromJSON(json.nets[i]);
    var dummy_candidate = {};
    dummy_candidate.net = net;
    this.evaluated_candidates.push(dummy_candidate);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.in_depth = json.in_depth; // depth of input volume
    this.filters = [];
    this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;
    this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;
    this.pad = typeof json.pad !== 'undefined' ? json.pad : 0;
    for(var i=0;i&lt;json.filters.length;i++) {
      var v = new Vol(0,0,0,0);
      v.<span class="apidocCodeKeywordSpan">fromJSON</span>(json.filters[i]);
      this.filters.push(v);
    }
    this.biases = new Vol(0,0,0,0);
    this.biases.fromJSON(json.biases);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.MagicNet.prototype.onFinishBatch" id="apidoc.element.convnetjs.MagicNet.prototype.onFinishBatch">
        function <span class="apidocSignatureSpan">convnetjs.MagicNet.prototype.</span>onFinishBatch
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onFinishBatch = function (f) { this.finish_batch_callback = f; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.MagicNet.prototype.onFinishFold" id="apidoc.element.convnetjs.MagicNet.prototype.onFinishFold">
        function <span class="apidocSignatureSpan">convnetjs.MagicNet.prototype.</span>onFinishFold
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onFinishFold = function (f) { this.finish_fold_callback = f; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.MagicNet.prototype.predict" id="apidoc.element.convnetjs.MagicNet.prototype.predict">
        function <span class="apidocSignatureSpan">convnetjs.MagicNet.prototype.</span>predict
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">predict = function (data) {
  var xout = this.predict_soft(data);
  if(xout.w.length !== 0) {
    var stats = maxmin(xout.w);
    var predicted_label = stats.maxi;
  } else {
    var predicted_label = -1; // error out
  }
  return predicted_label;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.MagicNet.prototype.predict_soft" id="apidoc.element.convnetjs.MagicNet.prototype.predict_soft">
        function <span class="apidocSignatureSpan">convnetjs.MagicNet.prototype.</span>predict_soft
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">predict_soft = function (data) {
  // forward prop the best networks
  // and accumulate probabilities at last layer into a an output Vol
  var nv = Math.min(this.ensemble_size, this.evaluated_candidates.length);
  if(nv === 0) { return new convnetjs.Vol(0,0,0); } // not sure what to do here? we're not ready yet
  var xout, n;
  for(var j=0;j&lt;nv;j++) {
    var net = this.evaluated_candidates[j].net;
    var x = net.forward(data);
    if(j===0) {
      xout = x;
      n = x.w.length;
    } else {
      // add it on
      for(var d=0;d&lt;n;d++) {
        xout.w[d] += x.w[d];
      }
    }
  }
  // produce average
  for(var d=0;d&lt;n;d++) {
    xout.w[d] /= n;
  }
  return xout;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  for(var d=0;d&lt;n;d++) {
    xout.w[d] /= n;
  }
  return xout;
},

predict: function(data) {
  var xout = this.<span class="apidocCodeKeywordSpan">predict_soft</span>(data);
  if(xout.w.length !== 0) {
    var stats = maxmin(xout.w);
    var predicted_label = stats.maxi;
  } else {
    var predicted_label = -1; // error out
  }
  return predicted_label;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.MagicNet.prototype.sampleCandidate" id="apidoc.element.convnetjs.MagicNet.prototype.sampleCandidate">
        function <span class="apidocSignatureSpan">convnetjs.MagicNet.prototype.</span>sampleCandidate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sampleCandidate = function () {
  var input_depth = this.data[0].w.length;
  var num_classes = this.unique_labels.length;

  // sample network topology and hyperparameters
  var layer_defs = [];
  layer_defs.push({type:'input', out_sx:1, out_sy:1, out_depth: input_depth});
  var nl = weightedSample([0,1,2,3], [0.2, 0.3, 0.3, 0.2]); // prefer nets with 1,2 hidden layers
  for(var q=0;q&lt;nl;q++) {
    var ni = randi(this.neurons_min, this.neurons_max);
    var act = ['tanh','maxout','relu'][randi(0,3)];
    if(randf(0,1)&lt;0.5) {
      var dp = Math.random();
      layer_defs.push({type:'fc', num_neurons: ni, activation: act, drop_prob: dp});
    } else {
      layer_defs.push({type:'fc', num_neurons: ni, activation: act});
    }
  }
  layer_defs.push({type:'softmax', num_classes: num_classes});
  var net = new Net();
  net.makeLayers(layer_defs);

  // sample training hyperparameters
  var bs = randi(this.batch_size_min, this.batch_size_max); // batch size
  var l2 = Math.pow(10, randf(this.l2_decay_min, this.l2_decay_max)); // l2 weight decay
  var lr = Math.pow(10, randf(this.learning_rate_min, this.learning_rate_max)); // learning rate
  var mom = randf(this.momentum_min, this.momentum_max); // momentum. Lets just use 0.9, works okay usually ;p
  var tp = randf(0,1); // trainer type
  var trainer_def;
  if(tp&lt;0.33) {
    trainer_def = {method:'adadelta', batch_size:bs, l2_decay:l2};
  } else if(tp&lt;0.66) {
    trainer_def = {method:'adagrad', learning_rate: lr, batch_size:bs, l2_decay:l2};
  } else {
    trainer_def = {method:'sgd', learning_rate: lr, momentum: mom, batch_size:bs, l2_decay:l2};
  }

  var trainer = new Trainer(net, trainer_def);

  var cand = {};
  cand.acc = [];
  cand.accv = 0; // this will maintained as sum(acc) for convenience
  cand.layer_defs = layer_defs;
  cand.trainer_def = trainer_def;
  cand.net = net;
  cand.trainer = trainer;
  return cand;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return cand;
},

// sets this.candidates with this.num_candidates candidate nets
sampleCandidates: function() {
  this.candidates = []; // flush, if any
  for(var i=0;i&lt;this.num_candidates;i++) {
    var cand = this.<span class="apidocCodeKeywordSpan">sampleCandidate</span>();
    this.candidates.push(cand);
  }
},

step: function() {

  // run an example through current candidate
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.MagicNet.prototype.sampleCandidates" id="apidoc.element.convnetjs.MagicNet.prototype.sampleCandidates">
        function <span class="apidocSignatureSpan">convnetjs.MagicNet.prototype.</span>sampleCandidates
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sampleCandidates = function () {
  this.candidates = []; // flush, if any
  for(var i=0;i&lt;this.num_candidates;i++) {
    var cand = this.sampleCandidate();
    this.candidates.push(cand);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// callbacks
this.finish_fold_callback = null;
this.finish_batch_callback = null;

// initializations
if(this.data.length &gt; 0) {
  this.sampleFolds();
  this.<span class="apidocCodeKeywordSpan">sampleCandidates</span>();
}
  };

  MagicNet.prototype = {

// sets this.folds to a sampling of this.num_folds folds
sampleFolds: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.MagicNet.prototype.sampleFolds" id="apidoc.element.convnetjs.MagicNet.prototype.sampleFolds">
        function <span class="apidocSignatureSpan">convnetjs.MagicNet.prototype.</span>sampleFolds
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sampleFolds = function () {
  var N = this.data.length;
  var num_train = Math.floor(this.train_ratio * N);
  this.folds = []; // flush folds, if any
  for(var i=0;i&lt;this.num_folds;i++) {
    var p = randperm(N);
    this.folds.push({train_ix: p.slice(0, num_train), test_ix: p.slice(num_train, N)});
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// callbacks
this.finish_fold_callback = null;
this.finish_batch_callback = null;

// initializations
if(this.data.length &gt; 0) {
  this.<span class="apidocCodeKeywordSpan">sampleFolds</span>();
  this.sampleCandidates();
}
  };

  MagicNet.prototype = {

// sets this.folds to a sampling of this.num_folds folds
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.MagicNet.prototype.step" id="apidoc.element.convnetjs.MagicNet.prototype.step">
        function <span class="apidocSignatureSpan">convnetjs.MagicNet.prototype.</span>step
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">step = function () {

  // run an example through current candidate
  this.iter++;

  // step all candidates on a random data point
  var fold = this.folds[this.foldix]; // active fold
  var dataix = fold.train_ix[randi(0, fold.train_ix.length)];
  for(var k=0;k&lt;this.candidates.length;k++) {
    var x = this.data[dataix];
    var l = this.labels[dataix];
    this.candidates[k].trainer.train(x, l);
  }

  // process consequences: sample new folds, or candidates
  var lastiter = this.num_epochs * fold.train_ix.length;
  if(this.iter &gt;= lastiter) {
    // finished evaluation of this fold. Get final validation
    // accuracies, record them, and go on to next fold.
    var val_acc = this.evalValErrors();
    for(var k=0;k&lt;this.candidates.length;k++) {
      var c = this.candidates[k];
      c.acc.push(val_acc[k]);
      c.accv += val_acc[k];
    }
    this.iter = 0; // reset step number
    this.foldix++; // increment fold

    if(this.finish_fold_callback !== null) {
      this.finish_fold_callback();
    }

    if(this.foldix &gt;= this.folds.length) {
      // we finished all folds as well! Record these candidates
      // and sample new ones to evaluate.
      for(var k=0;k&lt;this.candidates.length;k++) {
        this.evaluated_candidates.push(this.candidates[k]);
      }
      // sort evaluated candidates according to accuracy achieved
      this.evaluated_candidates.sort(function(a, b) {
        return (a.accv / a.acc.length)
             &gt; (b.accv / b.acc.length)
             ? -1 : 1;
      });
      // and clip only to the top few ones (lets place limit at 3*ensemble_size)
      // otherwise there are concerns with keeping these all in memory
      // if MagicNet is being evaluated for a very long time
      if(this.evaluated_candidates.length &gt; 3 * this.ensemble_size) {
        this.evaluated_candidates = this.evaluated_candidates.slice(0, 3 * this.ensemble_size);
      }
      if(this.finish_batch_callback !== null) {
        this.finish_batch_callback();
      }
      this.sampleCandidates(); // begin with new candidates
      this.foldix = 0; // reset this
    } else {
      // we will go on to another fold. reset all candidates nets
      for(var k=0;k&lt;this.candidates.length;k++) {
        var c = this.candidates[k];
        var net = new Net();
        net.makeLayers(c.layer_defs);
        var trainer = new Trainer(net, c.trainer_def);
        c.net = net;
        c.trainer = trainer;
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.MagicNet.prototype.toJSON" id="apidoc.element.convnetjs.MagicNet.prototype.toJSON">
        function <span class="apidocSignatureSpan">convnetjs.MagicNet.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  // dump the top ensemble_size networks as a list
  var nv = Math.min(this.ensemble_size, this.evaluated_candidates.length);
  var json = {};
  json.nets = [];
  for(var i=0;i&lt;nv;i++) {
    json.nets.push(this.evaluated_candidates[i].net.toJSON());
  }
  return json;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  json.l1_decay_mul = this.l1_decay_mul;
  json.l2_decay_mul = this.l2_decay_mul;
  json.pad = this.pad;
  json.filters = [];
  for(var i=0;i&lt;this.filters.length;i++) {
    json.filters.push(this.filters[i].<span class="apidocCodeKeywordSpan">toJSON</span>());
  }
  json.biases = this.biases.toJSON();
  return json;
},
fromJSON: function(json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.MaxoutLayer" id="apidoc.module.convnetjs.MaxoutLayer">module convnetjs.MaxoutLayer</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.MaxoutLayer.MaxoutLayer" id="apidoc.element.convnetjs.MaxoutLayer.MaxoutLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>MaxoutLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MaxoutLayer = function (opt) {
  var opt = opt || {};

  // required
  this.group_size = typeof opt.group_size !== 'undefined' ? opt.group_size : 2;

  // computed
  this.out_sx = opt.in_sx;
  this.out_sy = opt.in_sy;
  this.out_depth = Math.floor(opt.in_depth / this.group_size);
  this.layer_type = 'maxout';

  this.switches = global.zeros(this.out_sx*this.out_sy*this.out_depth); // useful for backprop
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      case 'softmax': this.layers.push(new global.SoftmaxLayer(def)); break;
      case 'regression': this.layers.push(new global.RegressionLayer(def)); break;
      case 'conv': this.layers.push(new global.ConvLayer(def)); break;
      case 'pool': this.layers.push(new global.PoolLayer(def)); break;
      case 'relu': this.layers.push(new global.ReluLayer(def)); break;
      case 'sigmoid': this.layers.push(new global.SigmoidLayer(def)); break;
      case 'tanh': this.layers.push(new global.TanhLayer(def)); break;
      case 'maxout': this.layers.push(new global.<span class="apidocCodeKeywordSpan">MaxoutLayer</span>(def)); break;
      case 'quadtransform': this.layers.push(new global.QuadTransformLayer(def)); break;
      case 'svm': this.layers.push(new global.SVMLayer(def)); break;
      default: console.log('ERROR: UNRECOGNIZED LAYER TYPE!');
    }
  }
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.MaxoutLayer.prototype" id="apidoc.module.convnetjs.MaxoutLayer.prototype">module convnetjs.MaxoutLayer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.MaxoutLayer.prototype.backward" id="apidoc.element.convnetjs.MaxoutLayer.prototype.backward">
        function <span class="apidocSignatureSpan">convnetjs.MaxoutLayer.prototype.</span>backward
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">backward = function () {
  var V = this.in_act; // we need to set dw of this
  var V2 = this.out_act;
  var N = this.out_depth;
  V.dw = global.zeros(V.w.length); // zero out gradient wrt data

  // pass the gradient through the appropriate switch
  if(this.out_sx === 1 &amp;&amp; this.out_sy === 1) {
    for(var i=0;i&lt;N;i++) {
      var chain_grad = V2.dw[i];
      V.dw[this.switches[i]] = chain_grad;
    }
  } else {
    // bleh okay, lets do this the hard way
    var n=0; // counter for switches
    for(var x=0;x&lt;V2.sx;x++) {
      for(var y=0;y&lt;V2.sy;y++) {
        for(var i=0;i&lt;N;i++) {
          var chain_grad = V2.get_grad(x,y,i);
          V.set_grad(x,y,this.switches[n],chain_grad);
          n++;
        }
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return act;
},

// backprop: compute gradients wrt all parameters
backward: function(y) {
  var N = this.layers.length;
  var loss = this.layers[N-1].<span class="apidocCodeKeywordSpan">backward</span>(y); // last layer assumed softmax
  for(var i=N-2;i&gt;=0;i--) { // first layer assumed input
    this.layers[i].backward();
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.MaxoutLayer.prototype.forward" id="apidoc.element.convnetjs.MaxoutLayer.prototype.forward">
        function <span class="apidocSignatureSpan">convnetjs.MaxoutLayer.prototype.</span>forward
        <span class="apidocSignatureSpan">(V, is_training)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forward = function (V, is_training) {
  this.in_act = V;
  var N = this.out_depth;
  var V2 = new Vol(this.out_sx, this.out_sy, this.out_depth, 0.0);

  // optimization branch. If we're operating on 1D arrays we dont have
  // to worry about keeping track of x,y,d coordinates inside
  // input volumes. In convnets we do :(
  if(this.out_sx === 1 &amp;&amp; this.out_sy === 1) {
    for(var i=0;i&lt;N;i++) {
      var ix = i * this.group_size; // base index offset
      var a = V.w[ix];
      var ai = 0;
      for(var j=1;j&lt;this.group_size;j++) {
        var a2 = V.w[ix+j];
        if(a2 &gt; a) {
          a = a2;
          ai = j;
        }
      }
      V2.w[i] = a;
      this.switches[i] = ix + ai;
    }
  } else {
    var n=0; // counter for switches
    for(var x=0;x&lt;V.sx;x++) {
      for(var y=0;y&lt;V.sy;y++) {
        for(var i=0;i&lt;N;i++) {
          var ix = i * this.group_size;
          var a = V.get(x, y, ix);
          var ai = 0;
          for(var j=1;j&lt;this.group_size;j++) {
            var a2 = V.get(x, y, ix+j);
            if(a2 &gt; a) {
              a = a2;
              ai = j;
            }
          }
          V2.set(x,y,i,a);
          this.switches[n] = ix + ai;
          n++;
        }
      }
    }

  }
  this.out_act = V2;
  return this.out_act;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
},

// forward prop the network. A trainer will pass in is_training = true
forward: function(V, is_training) {
  if(typeof(is_training)==='undefined') is_training = false;
  var act = this.layers[0].<span class="apidocCodeKeywordSpan">forward</span>(V, is_training);
  for(var i=1;i&lt;this.layers.length;i++) {
    act = this.layers[i].forward(act, is_training);
  }
  return act;
},

// backprop: compute gradients wrt all parameters
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.MaxoutLayer.prototype.fromJSON" id="apidoc.element.convnetjs.MaxoutLayer.prototype.fromJSON">
        function <span class="apidocSignatureSpan">convnetjs.MaxoutLayer.prototype.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
  this.out_sy = json.out_sy;
  this.layer_type = json.layer_type;
  this.group_size = json.group_size;
  this.switches = global.zeros(this.group_size);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.in_depth = json.in_depth; // depth of input volume
    this.filters = [];
    this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;
    this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;
    this.pad = typeof json.pad !== 'undefined' ? json.pad : 0;
    for(var i=0;i&lt;json.filters.length;i++) {
      var v = new Vol(0,0,0,0);
      v.<span class="apidocCodeKeywordSpan">fromJSON</span>(json.filters[i]);
      this.filters.push(v);
    }
    this.biases = new Vol(0,0,0,0);
    this.biases.fromJSON(json.biases);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.MaxoutLayer.prototype.getParamsAndGrads" id="apidoc.element.convnetjs.MaxoutLayer.prototype.getParamsAndGrads">
        function <span class="apidocSignatureSpan">convnetjs.MaxoutLayer.prototype.</span>getParamsAndGrads
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getParamsAndGrads = function () {
  return [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
  var response = [];
  for(var i=0;i&lt;this.layers.length;i++) {
    var layer_reponse = this.layers[i].<span class="apidocCodeKeywordSpan">getParamsAndGrads</span>();
    for(var j=0;j&lt;layer_reponse.length;j++) {
      response.push(layer_reponse[j]);
    }
  }
  return response;
},
getPrediction: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.MaxoutLayer.prototype.toJSON" id="apidoc.element.convnetjs.MaxoutLayer.prototype.toJSON">
        function <span class="apidocSignatureSpan">convnetjs.MaxoutLayer.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  var json = {};
  json.out_depth = this.out_depth;
  json.out_sx = this.out_sx;
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  json.group_size = this.group_size;
  return json;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  json.l1_decay_mul = this.l1_decay_mul;
  json.l2_decay_mul = this.l2_decay_mul;
  json.pad = this.pad;
  json.filters = [];
  for(var i=0;i&lt;this.filters.length;i++) {
    json.filters.push(this.filters[i].<span class="apidocCodeKeywordSpan">toJSON</span>());
  }
  json.biases = this.biases.toJSON();
  return json;
},
fromJSON: function(json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.Net" id="apidoc.module.convnetjs.Net">module convnetjs.Net</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.Net.Net" id="apidoc.element.convnetjs.Net.Net">
        function <span class="apidocSignatureSpan">convnetjs.</span>Net
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Net = function (options) {
  this.layers = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var hl = opt.hidden_layer_sizes;
    for(var k=0;k&lt;hl.length;k++) {
      layer_defs.push({type:'fc', num_neurons:hl[k], activation:'relu'}); // relu by default
    }
  }
  layer_defs.push({type:'regression', num_neurons:num_actions}); // value function output
}
this.value_net = new convnetjs.<span class="apidocCodeKeywordSpan">Net</span>();
this.value_net.makeLayers(layer_defs);

// and finally we need a Temporal Difference Learning trainer!
var tdtrainer_options = {learning_rate:0.01, momentum:0.0, batch_size:64, l2_decay:0.01};
if(typeof opt.tdtrainer_options !== 'undefined') {
  tdtrainer_options = opt.tdtrainer_options; // allow user to overwrite this
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.Net.prototype" id="apidoc.module.convnetjs.Net.prototype">module convnetjs.Net.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.Net.prototype.backward" id="apidoc.element.convnetjs.Net.prototype.backward">
        function <span class="apidocSignatureSpan">convnetjs.Net.prototype.</span>backward
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">backward = function (y) {
  var N = this.layers.length;
  var loss = this.layers[N-1].backward(y); // last layer assumed softmax
  for(var i=N-2;i&gt;=0;i--) { // first layer assumed input
    this.layers[i].backward();
  }
  return loss;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return act;
},

// backprop: compute gradients wrt all parameters
backward: function(y) {
  var N = this.layers.length;
  var loss = this.layers[N-1].<span class="apidocCodeKeywordSpan">backward</span>(y); // last layer assumed softmax
  for(var i=N-2;i&gt;=0;i--) { // first layer assumed input
    this.layers[i].backward();
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.Net.prototype.forward" id="apidoc.element.convnetjs.Net.prototype.forward">
        function <span class="apidocSignatureSpan">convnetjs.Net.prototype.</span>forward
        <span class="apidocSignatureSpan">(V, is_training)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forward = function (V, is_training) {
  if(typeof(is_training)==='undefined') is_training = false;
  var act = this.layers[0].forward(V, is_training);
  for(var i=1;i&lt;this.layers.length;i++) {
    act = this.layers[i].forward(act, is_training);
  }
  return act;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
},

// forward prop the network. A trainer will pass in is_training = true
forward: function(V, is_training) {
  if(typeof(is_training)==='undefined') is_training = false;
  var act = this.layers[0].<span class="apidocCodeKeywordSpan">forward</span>(V, is_training);
  for(var i=1;i&lt;this.layers.length;i++) {
    act = this.layers[i].forward(act, is_training);
  }
  return act;
},

// backprop: compute gradients wrt all parameters
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.Net.prototype.fromJSON" id="apidoc.element.convnetjs.Net.prototype.fromJSON">
        function <span class="apidocSignatureSpan">convnetjs.Net.prototype.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  this.layers = [];
  for(var i=0;i&lt;json.layers.length;i++) {
    var Lj = json.layers[i]
    var t = Lj.layer_type;
    var L;
    if(t==='input') { L = new global.InputLayer(); }
    if(t==='relu') { L = new global.ReluLayer(); }
    if(t==='sigmoid') { L = new global.SigmoidLayer(); }
    if(t==='tanh') { L = new global.TanhLayer(); }
    if(t==='dropout') { L = new global.DropoutLayer(); }
    if(t==='conv') { L = new global.ConvLayer(); }
    if(t==='pool') { L = new global.PoolLayer(); }
    if(t==='lrn') { L = new global.LocalResponseNormalizationLayer(); }
    if(t==='softmax') { L = new global.SoftmaxLayer(); }
    if(t==='regression') { L = new global.RegressionLayer(); }
    if(t==='fc') { L = new global.FullyConnLayer(); }
    if(t==='maxout') { L = new global.MaxoutLayer(); }
    if(t==='quadtransform') { L = new global.QuadTransformLayer(); }
    if(t==='svm') { L = new global.SVMLayer(); }
    L.fromJSON(Lj);
    this.layers.push(L);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.in_depth = json.in_depth; // depth of input volume
    this.filters = [];
    this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;
    this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;
    this.pad = typeof json.pad !== 'undefined' ? json.pad : 0;
    for(var i=0;i&lt;json.filters.length;i++) {
      var v = new Vol(0,0,0,0);
      v.<span class="apidocCodeKeywordSpan">fromJSON</span>(json.filters[i]);
      this.filters.push(v);
    }
    this.biases = new Vol(0,0,0,0);
    this.biases.fromJSON(json.biases);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.Net.prototype.getParamsAndGrads" id="apidoc.element.convnetjs.Net.prototype.getParamsAndGrads">
        function <span class="apidocSignatureSpan">convnetjs.Net.prototype.</span>getParamsAndGrads
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getParamsAndGrads = function () {
  // accumulate parameters and gradients for the entire network
  var response = [];
  for(var i=0;i&lt;this.layers.length;i++) {
    var layer_reponse = this.layers[i].getParamsAndGrads();
    for(var j=0;j&lt;layer_reponse.length;j++) {
      response.push(layer_reponse[j]);
    }
  }
  return response;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
  var response = [];
  for(var i=0;i&lt;this.layers.length;i++) {
    var layer_reponse = this.layers[i].<span class="apidocCodeKeywordSpan">getParamsAndGrads</span>();
    for(var j=0;j&lt;layer_reponse.length;j++) {
      response.push(layer_reponse[j]);
    }
  }
  return response;
},
getPrediction: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.Net.prototype.getPrediction" id="apidoc.element.convnetjs.Net.prototype.getPrediction">
        function <span class="apidocSignatureSpan">convnetjs.Net.prototype.</span>getPrediction
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPrediction = function () {
  var S = this.layers[this.layers.length-1]; // softmax layer
  var p = S.out_act.w;
  var maxv = p[0];
  var maxi = 0;
  for(var i=1;i&lt;p.length;i++) {
    if(p[i] &gt; maxv) { maxv = p[i]; maxi = i;}
  }
  return maxi;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  for(var k=0;k&lt;this.candidates.length;k++) {
    var net = this.candidates[k].net;
    var v = 0.0;
    for(var q=0;q&lt;fold.test_ix.length;q++) {
      var x = this.data[fold.test_ix[q]];
      var l = this.labels[fold.test_ix[q]];
      net.forward(x);
      var yhat = net.<span class="apidocCodeKeywordSpan">getPrediction</span>();
      v += (yhat === l ? 1.0 : 0.0); // 0 1 loss
    }
    v /= fold.test_ix.length; // normalize
    vals.push(v);
  }
  return vals;
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.Net.prototype.makeLayers" id="apidoc.element.convnetjs.Net.prototype.makeLayers">
        function <span class="apidocSignatureSpan">convnetjs.Net.prototype.</span>makeLayers
        <span class="apidocSignatureSpan">(defs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeLayers = function (defs) {

  // few checks for now
  if(defs.length&lt;2) {console.log('ERROR! For now at least have input and softmax layers.');}
  if(defs[0].type !== 'input') {console.log('ERROR! For now first layer should be input.');}

  // desugar syntactic for adding activations and dropouts
  var desugar = function() {
    var new_defs = [];
    for(var i=0;i&lt;defs.length;i++) {
      var def = defs[i];

      if(def.type==='softmax' || def.type==='svm') {
        // add an fc layer here, there is no reason the user should
        // have to worry about this and we almost always want to
        new_defs.push({type:'fc', num_neurons: def.num_classes});
      }

      if(def.type==='regression') {
        // add an fc layer here, there is no reason the user should
        // have to worry about this and we almost always want to
        new_defs.push({type:'fc', num_neurons: def.num_neurons});
      }

      if((def.type==='fc' || def.type==='conv')
          &amp;&amp; typeof(def.bias_pref) === 'undefined'){
        def.bias_pref = 0.0;
        if(typeof def.activation !== 'undefined' &amp;&amp; def.activation === 'relu') {
          def.bias_pref = 0.1; // relus like a bit of positive bias to get gradients early
          // otherwise it's technically possible that a relu unit will never turn on (by chance)
          // and will never get any gradient and never contribute any computation. Dead relu.
        }
      }

      if(typeof def.tensor !== 'undefined') {
        // apply quadratic transform so that the upcoming multiply will include
        // quadratic terms, equivalent to doing a tensor product
        if(def.tensor) {
          new_defs.push({type: 'quadtransform'});
        }
      }

      new_defs.push(def);

      if(typeof def.activation !== 'undefined') {
        if(def.activation==='relu') { new_defs.push({type:'relu'}); }
        else if (def.activation==='sigmoid') { new_defs.push({type:'sigmoid'}); }
        else if (def.activation==='tanh') { new_defs.push({type:'tanh'}); }
        else if (def.activation==='maxout') {
          // create maxout activation, and pass along group size, if provided
          var gs = def.group_size !== 'undefined' ? def.group_size : 2;
          new_defs.push({type:'maxout', group_size:gs});
        }
        else { console.log('ERROR unsupported activation ' + def.activation); }
      }
      if(typeof def.drop_prob !== 'undefined' &amp;&amp; def.type !== 'dropout') {
        new_defs.push({type:'dropout', drop_prob: def.drop_prob});
      }

    }
    return new_defs;
  }
  defs = desugar(defs);

  // create the layers
  this.layers = [];
  for(var i=0;i&lt;defs.length;i++) {
    var def = defs[i];
    if(i&gt;0) {
      var prev = this.layers[i-1];
      def.in_sx = prev.out_sx;
      def.in_sy = prev.out_sy;
      def.in_depth = prev.out_depth;
    }

    switch(def.type) {
      case 'fc': this.layers.push(new global.FullyConnLayer(def)); break;
      case 'lrn': this.layers.push(new global.LocalResponseNormalizationLayer(def)); break;
      case 'dropout': this.layers.push(new global.DropoutLayer(def)); break;
      case 'input': this.layers.push(new global.InputLayer(def)); break;
      case 'softmax': this.layers.push(new global.SoftmaxLayer(def)); break;
      case 'regression': this.layers.push(new global.RegressionLayer(def)); break;
      case 'conv': this.layers.push(new global.ConvLayer(def)); break;
      case 'pool': this.layers.push(new global.PoolLayer(def)); break;
      case 'relu': this.layers.push(new global.ReluLayer(def)); break;
      case 'sigmoid': this.layers.push(new global.SigmoidLayer(def)); break;
      case 'tanh': this.layers.push(new global.TanhLayer(def)); break;
      case 'maxout': this.layers.push(new global.MaxoutLayer(def)); break;
      case 'quadtransform': this.layers.push(new global.QuadTransformLayer(def)); break;
      case 'svm': this.layers.push(new global.SVMLayer(def)); break;
      default: console.log('ERROR: UNRECOGNIZED LAYER TYPE!');
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    layer_defs.push({type:'fc', num_neurons: ni, activation: act, drop_prob: dp});
  } else {
    layer_defs.push({type:'fc', num_neurons: ni, activation: act});
  }
}
layer_defs.push({type:'softmax', num_classes: num_classes});
var net = new Net();
net.<span class="apidocCodeKeywordSpan">makeLayers</span>(layer_defs);

// sample training hyperparameters
var bs = randi(this.batch_size_min, this.batch_size_max); // batch size
var l2 = Math.pow(10, randf(this.l2_decay_min, this.l2_decay_max)); // l2 weight decay
var lr = Math.pow(10, randf(this.learning_rate_min, this.learning_rate_max)); // learning rate
var mom = randf(this.momentum_min, this.momentum_max); // momentum. Lets just use 0.9, works okay usually ;p
var tp = randf(0,1); // trainer type
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.Net.prototype.toJSON" id="apidoc.element.convnetjs.Net.prototype.toJSON">
        function <span class="apidocSignatureSpan">convnetjs.Net.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  var json = {};
  json.layers = [];
  for(var i=0;i&lt;this.layers.length;i++) {
    json.layers.push(this.layers[i].toJSON());
  }
  return json;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  json.l1_decay_mul = this.l1_decay_mul;
  json.l2_decay_mul = this.l2_decay_mul;
  json.pad = this.pad;
  json.filters = [];
  for(var i=0;i&lt;this.filters.length;i++) {
    json.filters.push(this.filters[i].<span class="apidocCodeKeywordSpan">toJSON</span>());
  }
  json.biases = this.biases.toJSON();
  return json;
},
fromJSON: function(json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.PoolLayer" id="apidoc.module.convnetjs.PoolLayer">module convnetjs.PoolLayer</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.PoolLayer.PoolLayer" id="apidoc.element.convnetjs.PoolLayer.PoolLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>PoolLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PoolLayer = function (opt) {

  var opt = opt || {};

  // required
  this.sx = opt.sx; // filter size
  this.in_depth = opt.in_depth;
  this.in_sx = opt.in_sx;
  this.in_sy = opt.in_sy;

  // optional
  this.sy = typeof opt.sy !== 'undefined' ? opt.sy : this.sx;
  this.stride = typeof opt.stride !== 'undefined' ? opt.stride : 2;
  this.pad = typeof opt.pad !== 'undefined' ? opt.pad : 0; // amount of 0 padding to add around borders of input volume

  // computed
  this.out_depth = this.in_depth;
  this.out_sx = Math.floor((this.in_sx + this.pad * 2 - this.sx) / this.stride + 1);
  this.out_sy = Math.floor((this.in_sy + this.pad * 2 - this.sy) / this.stride + 1);
  this.layer_type = 'pool';
  // store switches for x,y coordinates for where the max comes from, for each output neuron
  this.switchx = global.zeros(this.out_sx*this.out_sy*this.out_depth);
  this.switchy = global.zeros(this.out_sx*this.out_sy*this.out_depth);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 'fc': this.layers.push(new global.FullyConnLayer(def)); break;
case 'lrn': this.layers.push(new global.LocalResponseNormalizationLayer(def)); break;
case 'dropout': this.layers.push(new global.DropoutLayer(def)); break;
case 'input': this.layers.push(new global.InputLayer(def)); break;
case 'softmax': this.layers.push(new global.SoftmaxLayer(def)); break;
case 'regression': this.layers.push(new global.RegressionLayer(def)); break;
case 'conv': this.layers.push(new global.ConvLayer(def)); break;
case 'pool': this.layers.push(new global.<span class="apidocCodeKeywordSpan">PoolLayer</span>(def)); break;
case 'relu': this.layers.push(new global.ReluLayer(def)); break;
case 'sigmoid': this.layers.push(new global.SigmoidLayer(def)); break;
case 'tanh': this.layers.push(new global.TanhLayer(def)); break;
case 'maxout': this.layers.push(new global.MaxoutLayer(def)); break;
case 'quadtransform': this.layers.push(new global.QuadTransformLayer(def)); break;
case 'svm': this.layers.push(new global.SVMLayer(def)); break;
default: console.log('ERROR: UNRECOGNIZED LAYER TYPE!');
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.PoolLayer.prototype" id="apidoc.module.convnetjs.PoolLayer.prototype">module convnetjs.PoolLayer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.PoolLayer.prototype.backward" id="apidoc.element.convnetjs.PoolLayer.prototype.backward">
        function <span class="apidocSignatureSpan">convnetjs.PoolLayer.prototype.</span>backward
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">backward = function () {
  // pooling layers have no parameters, so simply compute
  // gradient wrt data here
  var V = this.in_act;
  V.dw = global.zeros(V.w.length); // zero out gradient wrt data
  var A = this.out_act; // computed in forward pass

  var n = 0;
  for(var d=0;d&lt;this.out_depth;d++) {
    var x = -this.pad;
    var y = -this.pad;
    for(var ax=0; ax&lt;this.out_sx; x+=this.stride,ax++) {
      y = -this.pad;
      for(var ay=0; ay&lt;this.out_sy; y+=this.stride,ay++) {

        var chain_grad = this.out_act.get_grad(ax,ay,d);
        V.add_grad(this.switchx[n], this.switchy[n], d, chain_grad);
        n++;

      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return act;
},

// backprop: compute gradients wrt all parameters
backward: function(y) {
  var N = this.layers.length;
  var loss = this.layers[N-1].<span class="apidocCodeKeywordSpan">backward</span>(y); // last layer assumed softmax
  for(var i=N-2;i&gt;=0;i--) { // first layer assumed input
    this.layers[i].backward();
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.PoolLayer.prototype.forward" id="apidoc.element.convnetjs.PoolLayer.prototype.forward">
        function <span class="apidocSignatureSpan">convnetjs.PoolLayer.prototype.</span>forward
        <span class="apidocSignatureSpan">(V, is_training)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forward = function (V, is_training) {
  this.in_act = V;

  var A = new Vol(this.out_sx, this.out_sy, this.out_depth, 0.0);

  var n=0; // a counter for switches
  for(var d=0;d&lt;this.out_depth;d++) {
    var x = -this.pad;
    var y = -this.pad;
    for(var ax=0; ax&lt;this.out_sx; x+=this.stride,ax++) {
      y = -this.pad;
      for(var ay=0; ay&lt;this.out_sy; y+=this.stride,ay++) {

        // convolve centered at this particular location
        var a = -99999; // hopefully small enough ;\
        var winx=-1,winy=-1;
        for(var fx=0;fx&lt;this.sx;fx++) {
          for(var fy=0;fy&lt;this.sy;fy++) {
            var oy = y+fy;
            var ox = x+fx;
            if(oy&gt;=0 &amp;&amp; oy&lt;V.sy &amp;&amp; ox&gt;=0 &amp;&amp; ox&lt;V.sx) {
              var v = V.get(ox, oy, d);
              // perform max pooling and store pointers to where
              // the max came from. This will speed up backprop
              // and can help make nice visualizations in future
              if(v &gt; a) { a = v; winx=ox; winy=oy;}
            }
          }
        }
        this.switchx[n] = winx;
        this.switchy[n] = winy;
        n++;
        A.set(ax, ay, d, a);
      }
    }
  }
  this.out_act = A;
  return this.out_act;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
},

// forward prop the network. A trainer will pass in is_training = true
forward: function(V, is_training) {
  if(typeof(is_training)==='undefined') is_training = false;
  var act = this.layers[0].<span class="apidocCodeKeywordSpan">forward</span>(V, is_training);
  for(var i=1;i&lt;this.layers.length;i++) {
    act = this.layers[i].forward(act, is_training);
  }
  return act;
},

// backprop: compute gradients wrt all parameters
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.PoolLayer.prototype.fromJSON" id="apidoc.element.convnetjs.PoolLayer.prototype.fromJSON">
        function <span class="apidocSignatureSpan">convnetjs.PoolLayer.prototype.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
  this.out_sy = json.out_sy;
  this.layer_type = json.layer_type;
  this.sx = json.sx;
  this.sy = json.sy;
  this.stride = json.stride;
  this.in_depth = json.in_depth;
  this.pad = typeof json.pad !== 'undefined' ? json.pad : 0; // backwards compatibility
  this.switchx = global.zeros(this.out_sx*this.out_sy*this.out_depth); // need to re-init these appropriately
  this.switchy = global.zeros(this.out_sx*this.out_sy*this.out_depth);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.in_depth = json.in_depth; // depth of input volume
    this.filters = [];
    this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;
    this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;
    this.pad = typeof json.pad !== 'undefined' ? json.pad : 0;
    for(var i=0;i&lt;json.filters.length;i++) {
      var v = new Vol(0,0,0,0);
      v.<span class="apidocCodeKeywordSpan">fromJSON</span>(json.filters[i]);
      this.filters.push(v);
    }
    this.biases = new Vol(0,0,0,0);
    this.biases.fromJSON(json.biases);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.PoolLayer.prototype.getParamsAndGrads" id="apidoc.element.convnetjs.PoolLayer.prototype.getParamsAndGrads">
        function <span class="apidocSignatureSpan">convnetjs.PoolLayer.prototype.</span>getParamsAndGrads
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getParamsAndGrads = function () {
  return [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
  var response = [];
  for(var i=0;i&lt;this.layers.length;i++) {
    var layer_reponse = this.layers[i].<span class="apidocCodeKeywordSpan">getParamsAndGrads</span>();
    for(var j=0;j&lt;layer_reponse.length;j++) {
      response.push(layer_reponse[j]);
    }
  }
  return response;
},
getPrediction: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.PoolLayer.prototype.toJSON" id="apidoc.element.convnetjs.PoolLayer.prototype.toJSON">
        function <span class="apidocSignatureSpan">convnetjs.PoolLayer.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  var json = {};
  json.sx = this.sx;
  json.sy = this.sy;
  json.stride = this.stride;
  json.in_depth = this.in_depth;
  json.out_depth = this.out_depth;
  json.out_sx = this.out_sx;
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  json.pad = this.pad;
  return json;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  json.l1_decay_mul = this.l1_decay_mul;
  json.l2_decay_mul = this.l2_decay_mul;
  json.pad = this.pad;
  json.filters = [];
  for(var i=0;i&lt;this.filters.length;i++) {
    json.filters.push(this.filters[i].<span class="apidocCodeKeywordSpan">toJSON</span>());
  }
  json.biases = this.biases.toJSON();
  return json;
},
fromJSON: function(json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.QuadTransformLayer" id="apidoc.module.convnetjs.QuadTransformLayer">module convnetjs.QuadTransformLayer</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.QuadTransformLayer.QuadTransformLayer" id="apidoc.element.convnetjs.QuadTransformLayer.QuadTransformLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>QuadTransformLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">QuadTransformLayer = function (opt) {
  var opt = opt || {};

  // computed
  this.out_sx = opt.in_sx;
  this.out_sy = opt.in_sy;
  // linear terms, and then quadratic terms, of which there are 1/2*n*(n+1),
  // (offdiagonals and the diagonal total) and arithmetic series.
  // Actually never mind, lets not be fancy here yet and just include
  // terms x_ix_j and x_jx_i twice. Half as efficient but much less
  // headache.
  this.out_depth = opt.in_depth + opt.in_depth * opt.in_depth;
  this.layer_type = 'quadtransform';

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      case 'regression': this.layers.push(new global.RegressionLayer(def)); break;
      case 'conv': this.layers.push(new global.ConvLayer(def)); break;
      case 'pool': this.layers.push(new global.PoolLayer(def)); break;
      case 'relu': this.layers.push(new global.ReluLayer(def)); break;
      case 'sigmoid': this.layers.push(new global.SigmoidLayer(def)); break;
      case 'tanh': this.layers.push(new global.TanhLayer(def)); break;
      case 'maxout': this.layers.push(new global.MaxoutLayer(def)); break;
      case 'quadtransform': this.layers.push(new global.<span class="apidocCodeKeywordSpan">QuadTransformLayer</span>(
def)); break;
      case 'svm': this.layers.push(new global.SVMLayer(def)); break;
      default: console.log('ERROR: UNRECOGNIZED LAYER TYPE!');
    }
  }
},

// forward prop the network. A trainer will pass in is_training = true
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.QuadTransformLayer.prototype" id="apidoc.module.convnetjs.QuadTransformLayer.prototype">module convnetjs.QuadTransformLayer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.QuadTransformLayer.prototype.backward" id="apidoc.element.convnetjs.QuadTransformLayer.prototype.backward">
        function <span class="apidocSignatureSpan">convnetjs.QuadTransformLayer.prototype.</span>backward
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">backward = function () {
  var V = this.in_act;
  V.dw = global.zeros(V.w.length); // zero out gradient wrt data
  var V2 = this.out_act;
  var N = this.out_depth;
  var Ni = V.depth;
  for(var x=0;x&lt;V.sx;x++) {
    for(var y=0;y&lt;V.sy;y++) {
      for(var i=0;i&lt;N;i++) {
        var chain_grad = V2.get_grad(x,y,i);
        if(i&lt;Ni) {
          V.add_grad(x,y,i,chain_grad);
        } else {
          var i0 = Math.floor((i-Ni)/Ni);
          var i1 = (i-Ni) - i0*Ni;
          V.add_grad(x,y,i0,V.get(x,y,i1)*chain_grad);
          V.add_grad(x,y,i1,V.get(x,y,i0)*chain_grad);
        }
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return act;
},

// backprop: compute gradients wrt all parameters
backward: function(y) {
  var N = this.layers.length;
  var loss = this.layers[N-1].<span class="apidocCodeKeywordSpan">backward</span>(y); // last layer assumed softmax
  for(var i=N-2;i&gt;=0;i--) { // first layer assumed input
    this.layers[i].backward();
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.QuadTransformLayer.prototype.forward" id="apidoc.element.convnetjs.QuadTransformLayer.prototype.forward">
        function <span class="apidocSignatureSpan">convnetjs.QuadTransformLayer.prototype.</span>forward
        <span class="apidocSignatureSpan">(V, is_training)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forward = function (V, is_training) {
  this.in_act = V;
  var N = this.out_depth;
  var Ni = V.depth;
  var V2 = new Vol(this.out_sx, this.out_sy, this.out_depth, 0.0);
  for(var x=0;x&lt;V.sx;x++) {
    for(var y=0;y&lt;V.sy;y++) {
      for(var i=0;i&lt;N;i++) {
        if(i&lt;Ni) {
          V2.set(x,y,i,V.get(x,y,i)); // copy these over (linear terms)
        } else {
          var i0 = Math.floor((i-Ni)/Ni);
          var i1 = (i-Ni) - i0*Ni;
          V2.set(x,y,i,V.get(x,y,i0) * V.get(x,y,i1)); // quadratic
        }
      }
    }
  }
  this.out_act = V2;
  return this.out_act; // dummy identity function for now
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
},

// forward prop the network. A trainer will pass in is_training = true
forward: function(V, is_training) {
  if(typeof(is_training)==='undefined') is_training = false;
  var act = this.layers[0].<span class="apidocCodeKeywordSpan">forward</span>(V, is_training);
  for(var i=1;i&lt;this.layers.length;i++) {
    act = this.layers[i].forward(act, is_training);
  }
  return act;
},

// backprop: compute gradients wrt all parameters
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.QuadTransformLayer.prototype.fromJSON" id="apidoc.element.convnetjs.QuadTransformLayer.prototype.fromJSON">
        function <span class="apidocSignatureSpan">convnetjs.QuadTransformLayer.prototype.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
  this.out_sy = json.out_sy;
  this.layer_type = json.layer_type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.in_depth = json.in_depth; // depth of input volume
    this.filters = [];
    this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;
    this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;
    this.pad = typeof json.pad !== 'undefined' ? json.pad : 0;
    for(var i=0;i&lt;json.filters.length;i++) {
      var v = new Vol(0,0,0,0);
      v.<span class="apidocCodeKeywordSpan">fromJSON</span>(json.filters[i]);
      this.filters.push(v);
    }
    this.biases = new Vol(0,0,0,0);
    this.biases.fromJSON(json.biases);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.QuadTransformLayer.prototype.getParamsAndGrads" id="apidoc.element.convnetjs.QuadTransformLayer.prototype.getParamsAndGrads">
        function <span class="apidocSignatureSpan">convnetjs.QuadTransformLayer.prototype.</span>getParamsAndGrads
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getParamsAndGrads = function () {
  return [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
  var response = [];
  for(var i=0;i&lt;this.layers.length;i++) {
    var layer_reponse = this.layers[i].<span class="apidocCodeKeywordSpan">getParamsAndGrads</span>();
    for(var j=0;j&lt;layer_reponse.length;j++) {
      response.push(layer_reponse[j]);
    }
  }
  return response;
},
getPrediction: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.QuadTransformLayer.prototype.toJSON" id="apidoc.element.convnetjs.QuadTransformLayer.prototype.toJSON">
        function <span class="apidocSignatureSpan">convnetjs.QuadTransformLayer.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  var json = {};
  json.out_depth = this.out_depth;
  json.out_sx = this.out_sx;
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  return json;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  json.l1_decay_mul = this.l1_decay_mul;
  json.l2_decay_mul = this.l2_decay_mul;
  json.pad = this.pad;
  json.filters = [];
  for(var i=0;i&lt;this.filters.length;i++) {
    json.filters.push(this.filters[i].<span class="apidocCodeKeywordSpan">toJSON</span>());
  }
  json.biases = this.biases.toJSON();
  return json;
},
fromJSON: function(json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.RegressionLayer" id="apidoc.module.convnetjs.RegressionLayer">module convnetjs.RegressionLayer</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.RegressionLayer.RegressionLayer" id="apidoc.element.convnetjs.RegressionLayer.RegressionLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>RegressionLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RegressionLayer = function (opt) {
  var opt = opt || {};

  // computed
  this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;
  this.out_depth = this.num_inputs;
  this.out_sx = 1;
  this.out_sy = 1;
  this.layer_type = 'regression';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

        switch(def.type) {
case 'fc': this.layers.push(new global.FullyConnLayer(def)); break;
case 'lrn': this.layers.push(new global.LocalResponseNormalizationLayer(def)); break;
case 'dropout': this.layers.push(new global.DropoutLayer(def)); break;
case 'input': this.layers.push(new global.InputLayer(def)); break;
case 'softmax': this.layers.push(new global.SoftmaxLayer(def)); break;
case 'regression': this.layers.push(new global.<span class="apidocCodeKeywordSpan">RegressionLayer</span>(def)); break
;
case 'conv': this.layers.push(new global.ConvLayer(def)); break;
case 'pool': this.layers.push(new global.PoolLayer(def)); break;
case 'relu': this.layers.push(new global.ReluLayer(def)); break;
case 'sigmoid': this.layers.push(new global.SigmoidLayer(def)); break;
case 'tanh': this.layers.push(new global.TanhLayer(def)); break;
case 'maxout': this.layers.push(new global.MaxoutLayer(def)); break;
case 'quadtransform': this.layers.push(new global.QuadTransformLayer(def)); break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.RegressionLayer.prototype" id="apidoc.module.convnetjs.RegressionLayer.prototype">module convnetjs.RegressionLayer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.RegressionLayer.prototype.backward" id="apidoc.element.convnetjs.RegressionLayer.prototype.backward">
        function <span class="apidocSignatureSpan">convnetjs.RegressionLayer.prototype.</span>backward
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">backward = function (y) {

  // compute and accumulate gradient wrt weights and bias of this layer
  var x = this.in_act;
  x.dw = global.zeros(x.w.length); // zero out the gradient of input Vol
  var loss = 0.0;
  if(y instanceof Array || y instanceof Float64Array) {
    for(var i=0;i&lt;this.out_depth;i++) {
      var dy = x.w[i] - y[i];
      x.dw[i] = dy;
      loss += 2*dy*dy;
    }
  } else {
    // assume it is a struct with entries .dim and .val
    // and we pass gradient only along dimension dim to be equal to val
    var i = y.dim;
    var yi = y.val;
    var dy = x.w[i] - yi;
    x.dw[i] = dy;
    loss += 2*dy*dy;
  }
  return loss;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return act;
},

// backprop: compute gradients wrt all parameters
backward: function(y) {
  var N = this.layers.length;
  var loss = this.layers[N-1].<span class="apidocCodeKeywordSpan">backward</span>(y); // last layer assumed softmax
  for(var i=N-2;i&gt;=0;i--) { // first layer assumed input
    this.layers[i].backward();
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.RegressionLayer.prototype.forward" id="apidoc.element.convnetjs.RegressionLayer.prototype.forward">
        function <span class="apidocSignatureSpan">convnetjs.RegressionLayer.prototype.</span>forward
        <span class="apidocSignatureSpan">(V, is_training)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forward = function (V, is_training) {
  this.in_act = V;
  this.out_act = V;
  return V; // identity function
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
},

// forward prop the network. A trainer will pass in is_training = true
forward: function(V, is_training) {
  if(typeof(is_training)==='undefined') is_training = false;
  var act = this.layers[0].<span class="apidocCodeKeywordSpan">forward</span>(V, is_training);
  for(var i=1;i&lt;this.layers.length;i++) {
    act = this.layers[i].forward(act, is_training);
  }
  return act;
},

// backprop: compute gradients wrt all parameters
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.RegressionLayer.prototype.fromJSON" id="apidoc.element.convnetjs.RegressionLayer.prototype.fromJSON">
        function <span class="apidocSignatureSpan">convnetjs.RegressionLayer.prototype.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
  this.out_sy = json.out_sy;
  this.layer_type = json.layer_type;
  this.num_inputs = json.num_inputs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.in_depth = json.in_depth; // depth of input volume
    this.filters = [];
    this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;
    this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;
    this.pad = typeof json.pad !== 'undefined' ? json.pad : 0;
    for(var i=0;i&lt;json.filters.length;i++) {
      var v = new Vol(0,0,0,0);
      v.<span class="apidocCodeKeywordSpan">fromJSON</span>(json.filters[i]);
      this.filters.push(v);
    }
    this.biases = new Vol(0,0,0,0);
    this.biases.fromJSON(json.biases);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.RegressionLayer.prototype.getParamsAndGrads" id="apidoc.element.convnetjs.RegressionLayer.prototype.getParamsAndGrads">
        function <span class="apidocSignatureSpan">convnetjs.RegressionLayer.prototype.</span>getParamsAndGrads
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getParamsAndGrads = function () {
  return [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
  var response = [];
  for(var i=0;i&lt;this.layers.length;i++) {
    var layer_reponse = this.layers[i].<span class="apidocCodeKeywordSpan">getParamsAndGrads</span>();
    for(var j=0;j&lt;layer_reponse.length;j++) {
      response.push(layer_reponse[j]);
    }
  }
  return response;
},
getPrediction: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.RegressionLayer.prototype.toJSON" id="apidoc.element.convnetjs.RegressionLayer.prototype.toJSON">
        function <span class="apidocSignatureSpan">convnetjs.RegressionLayer.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  var json = {};
  json.out_depth = this.out_depth;
  json.out_sx = this.out_sx;
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  json.num_inputs = this.num_inputs;
  return json;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  json.l1_decay_mul = this.l1_decay_mul;
  json.l2_decay_mul = this.l2_decay_mul;
  json.pad = this.pad;
  json.filters = [];
  for(var i=0;i&lt;this.filters.length;i++) {
    json.filters.push(this.filters[i].<span class="apidocCodeKeywordSpan">toJSON</span>());
  }
  json.biases = this.biases.toJSON();
  return json;
},
fromJSON: function(json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.ReluLayer" id="apidoc.module.convnetjs.ReluLayer">module convnetjs.ReluLayer</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.ReluLayer.ReluLayer" id="apidoc.element.convnetjs.ReluLayer.ReluLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>ReluLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ReluLayer = function (opt) {
  var opt = opt || {};

  // computed
  this.out_sx = opt.in_sx;
  this.out_sy = opt.in_sy;
  this.out_depth = opt.in_depth;
  this.layer_type = 'relu';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  case 'lrn': this.layers.push(new global.LocalResponseNormalizationLayer(def)); break;
  case 'dropout': this.layers.push(new global.DropoutLayer(def)); break;
  case 'input': this.layers.push(new global.InputLayer(def)); break;
  case 'softmax': this.layers.push(new global.SoftmaxLayer(def)); break;
  case 'regression': this.layers.push(new global.RegressionLayer(def)); break;
  case 'conv': this.layers.push(new global.ConvLayer(def)); break;
  case 'pool': this.layers.push(new global.PoolLayer(def)); break;
  case 'relu': this.layers.push(new global.<span class="apidocCodeKeywordSpan">ReluLayer</span>(def)); break;
  case 'sigmoid': this.layers.push(new global.SigmoidLayer(def)); break;
  case 'tanh': this.layers.push(new global.TanhLayer(def)); break;
  case 'maxout': this.layers.push(new global.MaxoutLayer(def)); break;
  case 'quadtransform': this.layers.push(new global.QuadTransformLayer(def)); break;
  case 'svm': this.layers.push(new global.SVMLayer(def)); break;
  default: console.log('ERROR: UNRECOGNIZED LAYER TYPE!');
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.ReluLayer.prototype" id="apidoc.module.convnetjs.ReluLayer.prototype">module convnetjs.ReluLayer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.ReluLayer.prototype.backward" id="apidoc.element.convnetjs.ReluLayer.prototype.backward">
        function <span class="apidocSignatureSpan">convnetjs.ReluLayer.prototype.</span>backward
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">backward = function () {
  var V = this.in_act; // we need to set dw of this
  var V2 = this.out_act;
  var N = V.w.length;
  V.dw = global.zeros(N); // zero out gradient wrt data
  for(var i=0;i&lt;N;i++) {
    if(V2.w[i] &lt;= 0) V.dw[i] = 0; // threshold
    else V.dw[i] = V2.dw[i];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return act;
},

// backprop: compute gradients wrt all parameters
backward: function(y) {
  var N = this.layers.length;
  var loss = this.layers[N-1].<span class="apidocCodeKeywordSpan">backward</span>(y); // last layer assumed softmax
  for(var i=N-2;i&gt;=0;i--) { // first layer assumed input
    this.layers[i].backward();
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.ReluLayer.prototype.forward" id="apidoc.element.convnetjs.ReluLayer.prototype.forward">
        function <span class="apidocSignatureSpan">convnetjs.ReluLayer.prototype.</span>forward
        <span class="apidocSignatureSpan">(V, is_training)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forward = function (V, is_training) {
  this.in_act = V;
  var V2 = V.clone();
  var N = V.w.length;
  var V2w = V2.w;
  for(var i=0;i&lt;N;i++) {
    if(V2w[i] &lt; 0) V2w[i] = 0; // threshold at 0
  }
  this.out_act = V2;
  return this.out_act;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
},

// forward prop the network. A trainer will pass in is_training = true
forward: function(V, is_training) {
  if(typeof(is_training)==='undefined') is_training = false;
  var act = this.layers[0].<span class="apidocCodeKeywordSpan">forward</span>(V, is_training);
  for(var i=1;i&lt;this.layers.length;i++) {
    act = this.layers[i].forward(act, is_training);
  }
  return act;
},

// backprop: compute gradients wrt all parameters
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.ReluLayer.prototype.fromJSON" id="apidoc.element.convnetjs.ReluLayer.prototype.fromJSON">
        function <span class="apidocSignatureSpan">convnetjs.ReluLayer.prototype.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
  this.out_sy = json.out_sy;
  this.layer_type = json.layer_type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.in_depth = json.in_depth; // depth of input volume
    this.filters = [];
    this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;
    this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;
    this.pad = typeof json.pad !== 'undefined' ? json.pad : 0;
    for(var i=0;i&lt;json.filters.length;i++) {
      var v = new Vol(0,0,0,0);
      v.<span class="apidocCodeKeywordSpan">fromJSON</span>(json.filters[i]);
      this.filters.push(v);
    }
    this.biases = new Vol(0,0,0,0);
    this.biases.fromJSON(json.biases);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.ReluLayer.prototype.getParamsAndGrads" id="apidoc.element.convnetjs.ReluLayer.prototype.getParamsAndGrads">
        function <span class="apidocSignatureSpan">convnetjs.ReluLayer.prototype.</span>getParamsAndGrads
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getParamsAndGrads = function () {
  return [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
  var response = [];
  for(var i=0;i&lt;this.layers.length;i++) {
    var layer_reponse = this.layers[i].<span class="apidocCodeKeywordSpan">getParamsAndGrads</span>();
    for(var j=0;j&lt;layer_reponse.length;j++) {
      response.push(layer_reponse[j]);
    }
  }
  return response;
},
getPrediction: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.ReluLayer.prototype.toJSON" id="apidoc.element.convnetjs.ReluLayer.prototype.toJSON">
        function <span class="apidocSignatureSpan">convnetjs.ReluLayer.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  var json = {};
  json.out_depth = this.out_depth;
  json.out_sx = this.out_sx;
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  return json;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  json.l1_decay_mul = this.l1_decay_mul;
  json.l2_decay_mul = this.l2_decay_mul;
  json.pad = this.pad;
  json.filters = [];
  for(var i=0;i&lt;this.filters.length;i++) {
    json.filters.push(this.filters[i].<span class="apidocCodeKeywordSpan">toJSON</span>());
  }
  json.biases = this.biases.toJSON();
  return json;
},
fromJSON: function(json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.SVMLayer" id="apidoc.module.convnetjs.SVMLayer">module convnetjs.SVMLayer</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.SVMLayer.SVMLayer" id="apidoc.element.convnetjs.SVMLayer.SVMLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>SVMLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SVMLayer = function (opt) {
  var opt = opt || {};

  // computed
  this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;
  this.out_depth = this.num_inputs;
  this.out_sx = 1;
  this.out_sy = 1;
  this.layer_type = 'svm';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      case 'conv': this.layers.push(new global.ConvLayer(def)); break;
      case 'pool': this.layers.push(new global.PoolLayer(def)); break;
      case 'relu': this.layers.push(new global.ReluLayer(def)); break;
      case 'sigmoid': this.layers.push(new global.SigmoidLayer(def)); break;
      case 'tanh': this.layers.push(new global.TanhLayer(def)); break;
      case 'maxout': this.layers.push(new global.MaxoutLayer(def)); break;
      case 'quadtransform': this.layers.push(new global.QuadTransformLayer(def)); break;
      case 'svm': this.layers.push(new global.<span class="apidocCodeKeywordSpan">SVMLayer</span>(def)); break;
      default: console.log('ERROR: UNRECOGNIZED LAYER TYPE!');
    }
  }
},

// forward prop the network. A trainer will pass in is_training = true
forward: function(V, is_training) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.SVMLayer.prototype" id="apidoc.module.convnetjs.SVMLayer.prototype">module convnetjs.SVMLayer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.SVMLayer.prototype.backward" id="apidoc.element.convnetjs.SVMLayer.prototype.backward">
        function <span class="apidocSignatureSpan">convnetjs.SVMLayer.prototype.</span>backward
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">backward = function (y) {

  // compute and accumulate gradient wrt weights and bias of this layer
  var x = this.in_act;
  x.dw = global.zeros(x.w.length); // zero out the gradient of input Vol

  var yscore = x.w[y]; // score of ground truth
  var margin = 1.0;
  var loss = 0.0;
  for(var i=0;i&lt;this.out_depth;i++) {
    if(-yscore + x.w[i] + margin &gt; 0) {
      // violating example, apply loss
      // I love hinge loss, by the way. Truly.
      // Seriously, compare this SVM code with Softmax forward AND backprop code above
      // it's clear which one is superior, not only in code, simplicity
      // and beauty, but also in practice.
      x.dw[i] += 1;
      x.dw[y] -= 1;
      loss += -yscore + x.w[i] + margin;
    }
  }

  return loss;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return act;
},

// backprop: compute gradients wrt all parameters
backward: function(y) {
  var N = this.layers.length;
  var loss = this.layers[N-1].<span class="apidocCodeKeywordSpan">backward</span>(y); // last layer assumed softmax
  for(var i=N-2;i&gt;=0;i--) { // first layer assumed input
    this.layers[i].backward();
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.SVMLayer.prototype.forward" id="apidoc.element.convnetjs.SVMLayer.prototype.forward">
        function <span class="apidocSignatureSpan">convnetjs.SVMLayer.prototype.</span>forward
        <span class="apidocSignatureSpan">(V, is_training)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forward = function (V, is_training) {
  this.in_act = V;
  this.out_act = V; // nothing to do, output raw scores
  return V;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
},

// forward prop the network. A trainer will pass in is_training = true
forward: function(V, is_training) {
  if(typeof(is_training)==='undefined') is_training = false;
  var act = this.layers[0].<span class="apidocCodeKeywordSpan">forward</span>(V, is_training);
  for(var i=1;i&lt;this.layers.length;i++) {
    act = this.layers[i].forward(act, is_training);
  }
  return act;
},

// backprop: compute gradients wrt all parameters
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.SVMLayer.prototype.fromJSON" id="apidoc.element.convnetjs.SVMLayer.prototype.fromJSON">
        function <span class="apidocSignatureSpan">convnetjs.SVMLayer.prototype.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
  this.out_sy = json.out_sy;
  this.layer_type = json.layer_type;
  this.num_inputs = json.num_inputs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.in_depth = json.in_depth; // depth of input volume
    this.filters = [];
    this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;
    this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;
    this.pad = typeof json.pad !== 'undefined' ? json.pad : 0;
    for(var i=0;i&lt;json.filters.length;i++) {
      var v = new Vol(0,0,0,0);
      v.<span class="apidocCodeKeywordSpan">fromJSON</span>(json.filters[i]);
      this.filters.push(v);
    }
    this.biases = new Vol(0,0,0,0);
    this.biases.fromJSON(json.biases);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.SVMLayer.prototype.getParamsAndGrads" id="apidoc.element.convnetjs.SVMLayer.prototype.getParamsAndGrads">
        function <span class="apidocSignatureSpan">convnetjs.SVMLayer.prototype.</span>getParamsAndGrads
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getParamsAndGrads = function () {
  return [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
  var response = [];
  for(var i=0;i&lt;this.layers.length;i++) {
    var layer_reponse = this.layers[i].<span class="apidocCodeKeywordSpan">getParamsAndGrads</span>();
    for(var j=0;j&lt;layer_reponse.length;j++) {
      response.push(layer_reponse[j]);
    }
  }
  return response;
},
getPrediction: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.SVMLayer.prototype.toJSON" id="apidoc.element.convnetjs.SVMLayer.prototype.toJSON">
        function <span class="apidocSignatureSpan">convnetjs.SVMLayer.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  var json = {};
  json.out_depth = this.out_depth;
  json.out_sx = this.out_sx;
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  json.num_inputs = this.num_inputs;
  return json;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  json.l1_decay_mul = this.l1_decay_mul;
  json.l2_decay_mul = this.l2_decay_mul;
  json.pad = this.pad;
  json.filters = [];
  for(var i=0;i&lt;this.filters.length;i++) {
    json.filters.push(this.filters[i].<span class="apidocCodeKeywordSpan">toJSON</span>());
  }
  json.biases = this.biases.toJSON();
  return json;
},
fromJSON: function(json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.SigmoidLayer" id="apidoc.module.convnetjs.SigmoidLayer">module convnetjs.SigmoidLayer</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.SigmoidLayer.SigmoidLayer" id="apidoc.element.convnetjs.SigmoidLayer.SigmoidLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>SigmoidLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SigmoidLayer = function (opt) {
  var opt = opt || {};

  // computed
  this.out_sx = opt.in_sx;
  this.out_sy = opt.in_sy;
  this.out_depth = opt.in_depth;
  this.layer_type = 'sigmoid';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    case 'dropout': this.layers.push(new global.DropoutLayer(def)); break;
    case 'input': this.layers.push(new global.InputLayer(def)); break;
    case 'softmax': this.layers.push(new global.SoftmaxLayer(def)); break;
    case 'regression': this.layers.push(new global.RegressionLayer(def)); break;
    case 'conv': this.layers.push(new global.ConvLayer(def)); break;
    case 'pool': this.layers.push(new global.PoolLayer(def)); break;
    case 'relu': this.layers.push(new global.ReluLayer(def)); break;
    case 'sigmoid': this.layers.push(new global.<span class="apidocCodeKeywordSpan">SigmoidLayer</span>(def)); break;
    case 'tanh': this.layers.push(new global.TanhLayer(def)); break;
    case 'maxout': this.layers.push(new global.MaxoutLayer(def)); break;
    case 'quadtransform': this.layers.push(new global.QuadTransformLayer(def)); break;
    case 'svm': this.layers.push(new global.SVMLayer(def)); break;
    default: console.log('ERROR: UNRECOGNIZED LAYER TYPE!');
  }
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.SigmoidLayer.prototype" id="apidoc.module.convnetjs.SigmoidLayer.prototype">module convnetjs.SigmoidLayer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.SigmoidLayer.prototype.backward" id="apidoc.element.convnetjs.SigmoidLayer.prototype.backward">
        function <span class="apidocSignatureSpan">convnetjs.SigmoidLayer.prototype.</span>backward
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">backward = function () {
  var V = this.in_act; // we need to set dw of this
  var V2 = this.out_act;
  var N = V.w.length;
  V.dw = global.zeros(N); // zero out gradient wrt data
  for(var i=0;i&lt;N;i++) {
    var v2wi = V2.w[i];
    V.dw[i] =  v2wi * (1.0 - v2wi) * V2.dw[i];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return act;
},

// backprop: compute gradients wrt all parameters
backward: function(y) {
  var N = this.layers.length;
  var loss = this.layers[N-1].<span class="apidocCodeKeywordSpan">backward</span>(y); // last layer assumed softmax
  for(var i=N-2;i&gt;=0;i--) { // first layer assumed input
    this.layers[i].backward();
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.SigmoidLayer.prototype.forward" id="apidoc.element.convnetjs.SigmoidLayer.prototype.forward">
        function <span class="apidocSignatureSpan">convnetjs.SigmoidLayer.prototype.</span>forward
        <span class="apidocSignatureSpan">(V, is_training)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forward = function (V, is_training) {
  this.in_act = V;
  var V2 = V.cloneAndZero();
  var N = V.w.length;
  var V2w = V2.w;
  var Vw = V.w;
  for(var i=0;i&lt;N;i++) {
    V2w[i] = 1.0/(1.0+Math.exp(-Vw[i]));
  }
  this.out_act = V2;
  return this.out_act;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
},

// forward prop the network. A trainer will pass in is_training = true
forward: function(V, is_training) {
  if(typeof(is_training)==='undefined') is_training = false;
  var act = this.layers[0].<span class="apidocCodeKeywordSpan">forward</span>(V, is_training);
  for(var i=1;i&lt;this.layers.length;i++) {
    act = this.layers[i].forward(act, is_training);
  }
  return act;
},

// backprop: compute gradients wrt all parameters
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.SigmoidLayer.prototype.fromJSON" id="apidoc.element.convnetjs.SigmoidLayer.prototype.fromJSON">
        function <span class="apidocSignatureSpan">convnetjs.SigmoidLayer.prototype.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
  this.out_sy = json.out_sy;
  this.layer_type = json.layer_type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.in_depth = json.in_depth; // depth of input volume
    this.filters = [];
    this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;
    this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;
    this.pad = typeof json.pad !== 'undefined' ? json.pad : 0;
    for(var i=0;i&lt;json.filters.length;i++) {
      var v = new Vol(0,0,0,0);
      v.<span class="apidocCodeKeywordSpan">fromJSON</span>(json.filters[i]);
      this.filters.push(v);
    }
    this.biases = new Vol(0,0,0,0);
    this.biases.fromJSON(json.biases);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.SigmoidLayer.prototype.getParamsAndGrads" id="apidoc.element.convnetjs.SigmoidLayer.prototype.getParamsAndGrads">
        function <span class="apidocSignatureSpan">convnetjs.SigmoidLayer.prototype.</span>getParamsAndGrads
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getParamsAndGrads = function () {
  return [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
  var response = [];
  for(var i=0;i&lt;this.layers.length;i++) {
    var layer_reponse = this.layers[i].<span class="apidocCodeKeywordSpan">getParamsAndGrads</span>();
    for(var j=0;j&lt;layer_reponse.length;j++) {
      response.push(layer_reponse[j]);
    }
  }
  return response;
},
getPrediction: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.SigmoidLayer.prototype.toJSON" id="apidoc.element.convnetjs.SigmoidLayer.prototype.toJSON">
        function <span class="apidocSignatureSpan">convnetjs.SigmoidLayer.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  var json = {};
  json.out_depth = this.out_depth;
  json.out_sx = this.out_sx;
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  return json;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  json.l1_decay_mul = this.l1_decay_mul;
  json.l2_decay_mul = this.l2_decay_mul;
  json.pad = this.pad;
  json.filters = [];
  for(var i=0;i&lt;this.filters.length;i++) {
    json.filters.push(this.filters[i].<span class="apidocCodeKeywordSpan">toJSON</span>());
  }
  json.biases = this.biases.toJSON();
  return json;
},
fromJSON: function(json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.SoftmaxLayer" id="apidoc.module.convnetjs.SoftmaxLayer">module convnetjs.SoftmaxLayer</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.SoftmaxLayer.SoftmaxLayer" id="apidoc.element.convnetjs.SoftmaxLayer.SoftmaxLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>SoftmaxLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">SoftmaxLayer = function (opt) {
  var opt = opt || {};

  // computed
  this.num_inputs = opt.in_sx * opt.in_sy * opt.in_depth;
  this.out_depth = this.num_inputs;
  this.out_sx = 1;
  this.out_sy = 1;
  this.layer_type = 'softmax';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

switch(def.type) {
  case 'fc': this.layers.push(new global.FullyConnLayer(def)); break;
  case 'lrn': this.layers.push(new global.LocalResponseNormalizationLayer(def)); break;
  case 'dropout': this.layers.push(new global.DropoutLayer(def)); break;
  case 'input': this.layers.push(new global.InputLayer(def)); break;
  case 'softmax': this.layers.push(new global.<span class="apidocCodeKeywordSpan">SoftmaxLayer</span>(def)); break;
  case 'regression': this.layers.push(new global.RegressionLayer(def)); break;
  case 'conv': this.layers.push(new global.ConvLayer(def)); break;
  case 'pool': this.layers.push(new global.PoolLayer(def)); break;
  case 'relu': this.layers.push(new global.ReluLayer(def)); break;
  case 'sigmoid': this.layers.push(new global.SigmoidLayer(def)); break;
  case 'tanh': this.layers.push(new global.TanhLayer(def)); break;
  case 'maxout': this.layers.push(new global.MaxoutLayer(def)); break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.SoftmaxLayer.prototype" id="apidoc.module.convnetjs.SoftmaxLayer.prototype">module convnetjs.SoftmaxLayer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.SoftmaxLayer.prototype.backward" id="apidoc.element.convnetjs.SoftmaxLayer.prototype.backward">
        function <span class="apidocSignatureSpan">convnetjs.SoftmaxLayer.prototype.</span>backward
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">backward = function (y) {

  // compute and accumulate gradient wrt weights and bias of this layer
  var x = this.in_act;
  x.dw = global.zeros(x.w.length); // zero out the gradient of input Vol

  for(var i=0;i&lt;this.out_depth;i++) {
    var indicator = i === y ? 1.0 : 0.0;
    var mul = -(indicator - this.es[i]);
    x.dw[i] = mul;
  }

  // loss is the class negative log likelihood
  return -Math.log(this.es[y]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return act;
},

// backprop: compute gradients wrt all parameters
backward: function(y) {
  var N = this.layers.length;
  var loss = this.layers[N-1].<span class="apidocCodeKeywordSpan">backward</span>(y); // last layer assumed softmax
  for(var i=N-2;i&gt;=0;i--) { // first layer assumed input
    this.layers[i].backward();
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.SoftmaxLayer.prototype.forward" id="apidoc.element.convnetjs.SoftmaxLayer.prototype.forward">
        function <span class="apidocSignatureSpan">convnetjs.SoftmaxLayer.prototype.</span>forward
        <span class="apidocSignatureSpan">(V, is_training)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forward = function (V, is_training) {
  this.in_act = V;

  var A = new Vol(1, 1, this.out_depth, 0.0);

  // compute max activation
  var as = V.w;
  var amax = V.w[0];
  for(var i=1;i&lt;this.out_depth;i++) {
    if(as[i] &gt; amax) amax = as[i];
  }

  // compute exponentials (carefully to not blow up)
  var es = global.zeros(this.out_depth);
  var esum = 0.0;
  for(var i=0;i&lt;this.out_depth;i++) {
    var e = Math.exp(as[i] - amax);
    esum += e;
    es[i] = e;
  }

  // normalize and output to sum to one
  for(var i=0;i&lt;this.out_depth;i++) {
    es[i] /= esum;
    A.w[i] = es[i];
  }

  this.es = es; // save these for backprop
  this.out_act = A;
  return this.out_act;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
},

// forward prop the network. A trainer will pass in is_training = true
forward: function(V, is_training) {
  if(typeof(is_training)==='undefined') is_training = false;
  var act = this.layers[0].<span class="apidocCodeKeywordSpan">forward</span>(V, is_training);
  for(var i=1;i&lt;this.layers.length;i++) {
    act = this.layers[i].forward(act, is_training);
  }
  return act;
},

// backprop: compute gradients wrt all parameters
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.SoftmaxLayer.prototype.fromJSON" id="apidoc.element.convnetjs.SoftmaxLayer.prototype.fromJSON">
        function <span class="apidocSignatureSpan">convnetjs.SoftmaxLayer.prototype.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
  this.out_sy = json.out_sy;
  this.layer_type = json.layer_type;
  this.num_inputs = json.num_inputs;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.in_depth = json.in_depth; // depth of input volume
    this.filters = [];
    this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;
    this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;
    this.pad = typeof json.pad !== 'undefined' ? json.pad : 0;
    for(var i=0;i&lt;json.filters.length;i++) {
      var v = new Vol(0,0,0,0);
      v.<span class="apidocCodeKeywordSpan">fromJSON</span>(json.filters[i]);
      this.filters.push(v);
    }
    this.biases = new Vol(0,0,0,0);
    this.biases.fromJSON(json.biases);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.SoftmaxLayer.prototype.getParamsAndGrads" id="apidoc.element.convnetjs.SoftmaxLayer.prototype.getParamsAndGrads">
        function <span class="apidocSignatureSpan">convnetjs.SoftmaxLayer.prototype.</span>getParamsAndGrads
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getParamsAndGrads = function () {
  return [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
  var response = [];
  for(var i=0;i&lt;this.layers.length;i++) {
    var layer_reponse = this.layers[i].<span class="apidocCodeKeywordSpan">getParamsAndGrads</span>();
    for(var j=0;j&lt;layer_reponse.length;j++) {
      response.push(layer_reponse[j]);
    }
  }
  return response;
},
getPrediction: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.SoftmaxLayer.prototype.toJSON" id="apidoc.element.convnetjs.SoftmaxLayer.prototype.toJSON">
        function <span class="apidocSignatureSpan">convnetjs.SoftmaxLayer.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  var json = {};
  json.out_depth = this.out_depth;
  json.out_sx = this.out_sx;
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  json.num_inputs = this.num_inputs;
  return json;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  json.l1_decay_mul = this.l1_decay_mul;
  json.l2_decay_mul = this.l2_decay_mul;
  json.pad = this.pad;
  json.filters = [];
  for(var i=0;i&lt;this.filters.length;i++) {
    json.filters.push(this.filters[i].<span class="apidocCodeKeywordSpan">toJSON</span>());
  }
  json.biases = this.biases.toJSON();
  return json;
},
fromJSON: function(json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.TanhLayer" id="apidoc.module.convnetjs.TanhLayer">module convnetjs.TanhLayer</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.TanhLayer.TanhLayer" id="apidoc.element.convnetjs.TanhLayer.TanhLayer">
        function <span class="apidocSignatureSpan">convnetjs.</span>TanhLayer
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TanhLayer = function (opt) {
  var opt = opt || {};

  // computed
  this.out_sx = opt.in_sx;
  this.out_sy = opt.in_sy;
  this.out_depth = opt.in_depth;
  this.layer_type = 'tanh';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      case 'input': this.layers.push(new global.InputLayer(def)); break;
      case 'softmax': this.layers.push(new global.SoftmaxLayer(def)); break;
      case 'regression': this.layers.push(new global.RegressionLayer(def)); break;
      case 'conv': this.layers.push(new global.ConvLayer(def)); break;
      case 'pool': this.layers.push(new global.PoolLayer(def)); break;
      case 'relu': this.layers.push(new global.ReluLayer(def)); break;
      case 'sigmoid': this.layers.push(new global.SigmoidLayer(def)); break;
      case 'tanh': this.layers.push(new global.<span class="apidocCodeKeywordSpan">TanhLayer</span>(def)); break;
      case 'maxout': this.layers.push(new global.MaxoutLayer(def)); break;
      case 'quadtransform': this.layers.push(new global.QuadTransformLayer(def)); break;
      case 'svm': this.layers.push(new global.SVMLayer(def)); break;
      default: console.log('ERROR: UNRECOGNIZED LAYER TYPE!');
    }
  }
},
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.TanhLayer.prototype" id="apidoc.module.convnetjs.TanhLayer.prototype">module convnetjs.TanhLayer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.TanhLayer.prototype.backward" id="apidoc.element.convnetjs.TanhLayer.prototype.backward">
        function <span class="apidocSignatureSpan">convnetjs.TanhLayer.prototype.</span>backward
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">backward = function () {
  var V = this.in_act; // we need to set dw of this
  var V2 = this.out_act;
  var N = V.w.length;
  V.dw = global.zeros(N); // zero out gradient wrt data
  for(var i=0;i&lt;N;i++) {
    var v2wi = V2.w[i];
    V.dw[i] = (1.0 - v2wi * v2wi) * V2.dw[i];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return act;
},

// backprop: compute gradients wrt all parameters
backward: function(y) {
  var N = this.layers.length;
  var loss = this.layers[N-1].<span class="apidocCodeKeywordSpan">backward</span>(y); // last layer assumed softmax
  for(var i=N-2;i&gt;=0;i--) { // first layer assumed input
    this.layers[i].backward();
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.TanhLayer.prototype.forward" id="apidoc.element.convnetjs.TanhLayer.prototype.forward">
        function <span class="apidocSignatureSpan">convnetjs.TanhLayer.prototype.</span>forward
        <span class="apidocSignatureSpan">(V, is_training)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forward = function (V, is_training) {
  this.in_act = V;
  var V2 = V.cloneAndZero();
  var N = V.w.length;
  for(var i=0;i&lt;N;i++) {
    V2.w[i] = tanh(V.w[i]);
  }
  this.out_act = V2;
  return this.out_act;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
},

// forward prop the network. A trainer will pass in is_training = true
forward: function(V, is_training) {
  if(typeof(is_training)==='undefined') is_training = false;
  var act = this.layers[0].<span class="apidocCodeKeywordSpan">forward</span>(V, is_training);
  for(var i=1;i&lt;this.layers.length;i++) {
    act = this.layers[i].forward(act, is_training);
  }
  return act;
},

// backprop: compute gradients wrt all parameters
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.TanhLayer.prototype.fromJSON" id="apidoc.element.convnetjs.TanhLayer.prototype.fromJSON">
        function <span class="apidocSignatureSpan">convnetjs.TanhLayer.prototype.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
  this.out_sy = json.out_sy;
  this.layer_type = json.layer_type;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.in_depth = json.in_depth; // depth of input volume
    this.filters = [];
    this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;
    this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;
    this.pad = typeof json.pad !== 'undefined' ? json.pad : 0;
    for(var i=0;i&lt;json.filters.length;i++) {
      var v = new Vol(0,0,0,0);
      v.<span class="apidocCodeKeywordSpan">fromJSON</span>(json.filters[i]);
      this.filters.push(v);
    }
    this.biases = new Vol(0,0,0,0);
    this.biases.fromJSON(json.biases);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.TanhLayer.prototype.getParamsAndGrads" id="apidoc.element.convnetjs.TanhLayer.prototype.getParamsAndGrads">
        function <span class="apidocSignatureSpan">convnetjs.TanhLayer.prototype.</span>getParamsAndGrads
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getParamsAndGrads = function () {
  return [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
  return loss;
},
getParamsAndGrads: function() {
  // accumulate parameters and gradients for the entire network
  var response = [];
  for(var i=0;i&lt;this.layers.length;i++) {
    var layer_reponse = this.layers[i].<span class="apidocCodeKeywordSpan">getParamsAndGrads</span>();
    for(var j=0;j&lt;layer_reponse.length;j++) {
      response.push(layer_reponse[j]);
    }
  }
  return response;
},
getPrediction: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.TanhLayer.prototype.toJSON" id="apidoc.element.convnetjs.TanhLayer.prototype.toJSON">
        function <span class="apidocSignatureSpan">convnetjs.TanhLayer.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  var json = {};
  json.out_depth = this.out_depth;
  json.out_sx = this.out_sx;
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  return json;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  json.l1_decay_mul = this.l1_decay_mul;
  json.l2_decay_mul = this.l2_decay_mul;
  json.pad = this.pad;
  json.filters = [];
  for(var i=0;i&lt;this.filters.length;i++) {
    json.filters.push(this.filters[i].<span class="apidocCodeKeywordSpan">toJSON</span>());
  }
  json.biases = this.biases.toJSON();
  return json;
},
fromJSON: function(json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.Trainer" id="apidoc.module.convnetjs.Trainer">module convnetjs.Trainer</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.Trainer.Trainer" id="apidoc.element.convnetjs.Trainer.Trainer">
        function <span class="apidocSignatureSpan">convnetjs.</span>Trainer
        <span class="apidocSignatureSpan">(net, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Trainer = function (net, options) {

  this.net = net;

  var options = options || {};
  this.learning_rate = typeof options.learning_rate !== 'undefined' ? options.learning_rate : 0.01;
  this.l1_decay = typeof options.l1_decay !== 'undefined' ? options.l1_decay : 0.0;
  this.l2_decay = typeof options.l2_decay !== 'undefined' ? options.l2_decay : 0.0;
  this.batch_size = typeof options.batch_size !== 'undefined' ? options.batch_size : 1;
  this.method = typeof options.method !== 'undefined' ? options.method : 'sgd'; // sgd/adagrad/adadelta/windowgrad

  this.momentum = typeof options.momentum !== 'undefined' ? options.momentum : 0.9;
  this.ro = typeof options.ro !== 'undefined' ? options.ro : 0.95; // used in adadelta
  this.eps = typeof options.eps !== 'undefined' ? options.eps : 1e-6; // used in adadelta

  this.k = 0; // iteration counter
  this.gsum = []; // last iteration gradients (used for momentum calculations)
  this.xsum = []; // used in adadelta
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.Trainer.prototype" id="apidoc.module.convnetjs.Trainer.prototype">module convnetjs.Trainer.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.Trainer.prototype.train" id="apidoc.element.convnetjs.Trainer.prototype.train">
        function <span class="apidocSignatureSpan">convnetjs.Trainer.prototype.</span>train
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">train = function (x, y) {

  var start = new Date().getTime();
  this.net.forward(x, true); // also set the flag that lets the net know we're just training
  var end = new Date().getTime();
  var fwd_time = end - start;

  var start = new Date().getTime();
  var cost_loss = this.net.backward(y);
  var l2_decay_loss = 0.0;
  var l1_decay_loss = 0.0;
  var end = new Date().getTime();
  var bwd_time = end - start;

  this.k++;
  if(this.k % this.batch_size === 0) {

    var pglist = this.net.getParamsAndGrads();

    // initialize lists for accumulators. Will only be done once on first iteration
    if(this.gsum.length === 0 &amp;&amp; (this.method !== 'sgd' || this.momentum &gt; 0.0)) {
      // only vanilla sgd doesnt need either lists
      // momentum needs gsum
      // adagrad needs gsum
      // adadelta needs gsum and xsum
      for(var i=0;i&lt;pglist.length;i++) {
        this.gsum.push(global.zeros(pglist[i].params.length));
        if(this.method === 'adadelta') {
          this.xsum.push(global.zeros(pglist[i].params.length));
        } else {
          this.xsum.push([]); // conserve memory
        }
      }
    }

    // perform an update for all sets of weights
    for(var i=0;i&lt;pglist.length;i++) {
      var pg = pglist[i]; // param, gradient, other options in future (custom learning rate etc)
      var p = pg.params;
      var g = pg.grads;

      // learning rate for some parameters.
      var l2_decay_mul = typeof pg.l2_decay_mul !== 'undefined' ? pg.l2_decay_mul : 1.0;
      var l1_decay_mul = typeof pg.l1_decay_mul !== 'undefined' ? pg.l1_decay_mul : 1.0;
      var l2_decay = this.l2_decay * l2_decay_mul;
      var l1_decay = this.l1_decay * l1_decay_mul;

      var plen = p.length;
      for(var j=0;j&lt;plen;j++) {
        l2_decay_loss += l2_decay*p[j]*p[j]/2; // accumulate weight decay loss
        l1_decay_loss += l1_decay*Math.abs(p[j]);
        var l1grad = l1_decay * (p[j] &gt; 0 ? 1 : -1);
        var l2grad = l2_decay * (p[j]);

        var gij = (l2grad + l1grad + g[j]) / this.batch_size; // raw batch gradient

        var gsumi = this.gsum[i];
        var xsumi = this.xsum[i];
        if(this.method === 'adagrad') {
          // adagrad update
          gsumi[j] = gsumi[j] + gij * gij;
          var dx = - this.learning_rate / Math.sqrt(gsumi[j] + this.eps) * gij;
          p[j] += dx;
        } else if(this.method === 'windowgrad') {
          // this is adagrad but with a moving window weighted average
          // so the gradient is not accumulated over the entire history of the run.
          // it's also referred to as Idea #1 in Zeiler paper on Adadelta. Seems reasonable to me!
          gsumi[j] = this.ro * gsumi[j] + (1-this.ro) * gij * gij;
          var dx = - this.learning_rate / Math.sqrt(gsumi[j] + this.eps) * gij; // eps added for better conditioning
          p[j] += dx;
        } else if(this.method === 'adadelta') {
          // assume adadelta if not sgd or adagrad
          gsumi[j] = this.ro * gsumi[j] + (1-this.ro) * gij * gij;
          var dx = - Math.sqrt((xsumi[j] + this.eps)/(gsumi[j] + this.eps)) * gij;
          xsumi[j] = this.ro * xsumi[j] + (1-this.ro) * dx * dx; // yes, xsum lags behind gsum by 1.
          p[j] += dx;
        } else {
          // assume SGD
          if(this.momentum &gt; 0.0) {
            // momentum update
            var dx = this.momentum * gsumi[j] - this.learning_rate * gij; // step
            gsumi[j] = dx; // back this up for next iteration of momentum
            p[j] += dx; // apply corrected gradient
          } else {
            // vanilla sgd
            p[j] +=  - this.learning_rate * gij;
          }
        }
        g[j] = 0.0; // zero out gradient so that we can begin accumulating anew
      }
    }
  }

  // appending softmax_loss for backwards compatibility, but from now on we will always use cost_loss
  // in future, TODO: have to completely redo the way loss is done around the network as currently
  // loss is a bit of a hack. Ideally, user should specify arbitrary number of loss functions on any layer
  // and it should all be computed corre ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// step all candidates on a random data point
var fold = this.folds[this.foldix]; // active fold
var dataix = fold.train_ix[randi(0, fold.train_ix.length)];
for(var k=0;k&lt;this.candidates.length;k++) {
  var x = this.data[dataix];
  var l = this.labels[dataix];
  this.candidates[k].trainer.<span class="apidocCodeKeywordSpan">train</span>(x, l);
}

// process consequences: sample new folds, or candidates
var lastiter = this.num_epochs * fold.train_ix.length;
if(this.iter &gt;= lastiter) {
  // finished evaluation of this fold. Get final validation
  // accuracies, record them, and go on to next fold.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.Vol" id="apidoc.module.convnetjs.Vol">module convnetjs.Vol</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.Vol.Vol" id="apidoc.element.convnetjs.Vol.Vol">
        function <span class="apidocSignatureSpan">convnetjs.</span>Vol
        <span class="apidocSignatureSpan">(sx, sy, depth, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Vol = function (sx, sy, depth, c) {
  // this is how you check if a variable is an array. Oh, Javascript :)
  if(Object.prototype.toString.call(sx) === '[object Array]') {
    // we were given a list in sx, assume 1D volume and fill it up
    this.sx = 1;
    this.sy = 1;
    this.depth = sx.length;
    // we have to do the following copy because we want to use
    // fast typed arrays, not an ordinary javascript array
    this.w = global.zeros(this.depth);
    this.dw = global.zeros(this.depth);
    for(var i=0;i&lt;this.depth;i++) {
      this.w[i] = sx[i];
    }
  } else {
    // we were given dimensions of the vol
    this.sx = sx;
    this.sy = sy;
    this.depth = depth;
    var n = sx*sy*depth;
    this.w = global.zeros(n);
    this.dw = global.zeros(n);
    if(typeof c === 'undefined') {
      // weight normalization is done to equalize the output
      // variance of every neuron, otherwise neurons with a lot
      // of incoming connections have outputs of larger variance
      var scale = Math.sqrt(1.0/(sx*sy*depth));
      for(var i=0;i&lt;n;i++) {
        this.w[i] = global.randn(0.0, scale);
      }
    } else {
      for(var i=0;i&lt;n;i++) {
        this.w[i] = c;
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var maxmin = global.maxmin;
var randperm = global.randperm;
var weightedSample = global.weightedSample;
var getopt = global.getopt;
var arrUnique = global.arrUnique;

/*
A MagicNet takes data: a list of convnetjs.<span class="apidocCodeKeywordSpan">Vol</span>(), and labels
which for now are assumed to be class indeces 0..K. MagicNet then:
- creates data folds for cross-validation
- samples candidate networks
- evaluates candidate networks on all data folds
- produces predictions by model-averaging the best networks
*/
var MagicNet = function(data, labels, opt) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.convnetjs.Vol.prototype" id="apidoc.module.convnetjs.Vol.prototype">module convnetjs.Vol.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.convnetjs.Vol.prototype.add" id="apidoc.element.convnetjs.Vol.prototype.add">
        function <span class="apidocSignatureSpan">convnetjs.Vol.prototype.</span>add
        <span class="apidocSignatureSpan">(x, y, d, v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (x, y, d, v) {
  var ix=((this.sx * y)+x)*this.depth+d;
  this.w[ix] += v;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.action_window.shift();
  this.action_window.push(action);

  return action;
},
backward: function(reward) {
  this.latest_reward = reward;
  this.average_reward_window.<span class="apidocCodeKeywordSpan">add</span>(reward);
  this.reward_window.shift();
  this.reward_window.push(reward);

  if(!this.learning) { return; }

  // various book-keeping
  this.age += 1;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.Vol.prototype.addFrom" id="apidoc.element.convnetjs.Vol.prototype.addFrom">
        function <span class="apidocSignatureSpan">convnetjs.Vol.prototype.</span>addFrom
        <span class="apidocSignatureSpan">(V)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addFrom = function (V) { for(var k=0;k&lt;this.w.length;k++) { this.w[k] += V.w[k]; }}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.Vol.prototype.addFromScaled" id="apidoc.element.convnetjs.Vol.prototype.addFromScaled">
        function <span class="apidocSignatureSpan">convnetjs.Vol.prototype.</span>addFromScaled
        <span class="apidocSignatureSpan">(V, a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addFromScaled = function (V, a) { for(var k=0;k&lt;this.w.length;k++) { this.w[k] += a*V.w[k]; }}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.Vol.prototype.add_grad" id="apidoc.element.convnetjs.Vol.prototype.add_grad">
        function <span class="apidocSignatureSpan">convnetjs.Vol.prototype.</span>add_grad
        <span class="apidocSignatureSpan">(x, y, d, v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add_grad = function (x, y, d, v) {
  var ix = ((this.sx * y)+x)*this.depth+d;
  this.dw[ix] += v;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            for(var fx=0;fx&lt;f.sx;fx++) {
              for(var fy=0;fy&lt;f.sy;fy++) {
                for(var fd=0;fd&lt;f.depth;fd++) {
                  var oy = y+fy;
                  var ox = x+fx;
                  if(oy&gt;=0 &amp;&amp; oy&lt;V.sy &amp;&amp; ox&gt;=0 &amp;&amp; ox&lt;V.sx) {
// forward prop calculated: a += f.get(fx, fy, fd) * V.get(ox, oy, fd);
//f.<span class="apidocCodeKeywordSpan">add_grad</span>(fx, fy, fd, V.get(ox, oy, fd) * chain_grad);
//V.add_grad(ox, oy, fd, f.get(fx, fy, fd) * chain_grad);

// avoid function call overhead and use Vols directly for efficiency
var ix1 = ((V.sx * oy)+ox)*V.depth+fd;
var ix2 = ((f.sx * fy)+fx)*f.depth+fd;
f.dw[ix2] += V.w[ix1]*chain_grad;
V.dw[ix1] += f.w[ix2]*chain_grad;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.Vol.prototype.clone" id="apidoc.element.convnetjs.Vol.prototype.clone">
        function <span class="apidocSignatureSpan">convnetjs.Vol.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  var V = new Vol(this.sx, this.sy, this.depth, 0.0);
  var n = this.w.length;
  for(var i=0;i&lt;n;i++) { V.w[i] = this.w[i]; }
  return V;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.out_sy = opt.in_sy;
  this.out_depth = opt.in_depth;
  this.layer_type = 'relu';
}
ReluLayer.prototype = {
  forward: function(V, is_training) {
    this.in_act = V;
    var V2 = V.<span class="apidocCodeKeywordSpan">clone</span>();
    var N = V.w.length;
    var V2w = V2.w;
    for(var i=0;i&lt;N;i++) {
      if(V2w[i] &lt; 0) V2w[i] = 0; // threshold at 0
    }
    this.out_act = V2;
    return this.out_act;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.Vol.prototype.cloneAndZero" id="apidoc.element.convnetjs.Vol.prototype.cloneAndZero">
        function <span class="apidocSignatureSpan">convnetjs.Vol.prototype.</span>cloneAndZero
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cloneAndZero = function () { return new Vol(this.sx, this.sy, this.depth, 0.0)}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
} else {
  W = V;
}

if(fliplr) {
  // flip volume horziontally
  var W2 = W.<span class="apidocCodeKeywordSpan">cloneAndZero</span>();
  for(var x=0;x&lt;W.sx;x++) {
    for(var y=0;y&lt;W.sy;y++) {
      for(var d=0;d&lt;W.depth;d++) {
       W2.set(x,y,d,W.get(W.sx - x - 1,y,d)); // copy data over
      }
    }
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.Vol.prototype.fromJSON" id="apidoc.element.convnetjs.Vol.prototype.fromJSON">
        function <span class="apidocSignatureSpan">convnetjs.Vol.prototype.</span>fromJSON
        <span class="apidocSignatureSpan">(json)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (json) {
  this.sx = json.sx;
  this.sy = json.sy;
  this.depth = json.depth;

  var n = this.sx*this.sy*this.depth;
  this.w = global.zeros(n);
  this.dw = global.zeros(n);
  // copy over the elements.
  for(var i=0;i&lt;n;i++) {
    this.w[i] = json.w[i];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.in_depth = json.in_depth; // depth of input volume
    this.filters = [];
    this.l1_decay_mul = typeof json.l1_decay_mul !== 'undefined' ? json.l1_decay_mul : 1.0;
    this.l2_decay_mul = typeof json.l2_decay_mul !== 'undefined' ? json.l2_decay_mul : 1.0;
    this.pad = typeof json.pad !== 'undefined' ? json.pad : 0;
    for(var i=0;i&lt;json.filters.length;i++) {
      var v = new Vol(0,0,0,0);
      v.<span class="apidocCodeKeywordSpan">fromJSON</span>(json.filters[i]);
      this.filters.push(v);
    }
    this.biases = new Vol(0,0,0,0);
    this.biases.fromJSON(json.biases);
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.Vol.prototype.get" id="apidoc.element.convnetjs.Vol.prototype.get">
        function <span class="apidocSignatureSpan">convnetjs.Vol.prototype.</span>get
        <span class="apidocSignatureSpan">(x, y, d)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (x, y, d) {
  var ix=((this.sx * y)+x)*this.depth+d;
  return this.w[ix];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var W;
if(crop !== V.sx || dx!==0 || dy!==0) {
  W = new Vol(crop, crop, V.depth, 0.0);
  for(var x=0;x&lt;crop;x++) {
    for(var y=0;y&lt;crop;y++) {
      if(x+dx&lt;0 || x+dx&gt;=V.sx || y+dy&lt;0 || y+dy&gt;=V.sy) continue; // oob
      for(var d=0;d&lt;V.depth;d++) {
       W.set(x,y,d,V.<span class="apidocCodeKeywordSpan">get</span>(x+dx,y+dy,d)); // copy data over
      }
    }
  }
} else {
  W = V;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.Vol.prototype.get_grad" id="apidoc.element.convnetjs.Vol.prototype.get_grad">
        function <span class="apidocSignatureSpan">convnetjs.Vol.prototype.</span>get_grad
        <span class="apidocSignatureSpan">(x, y, d)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get_grad = function (x, y, d) {
  var ix = ((this.sx * y)+x)*this.depth+d;
  return this.dw[ix];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var x = -this.pad;
var y = -this.pad;
for(var ax=0; ax&lt;this.out_sx; x+=this.stride,ax++) {
  y = -this.pad;
  for(var ay=0; ay&lt;this.out_sy; y+=this.stride,ay++) {
    // convolve and add up the gradients.
    // could be more efficient, going for correctness first
    var chain_grad = this.out_act.<span class="apidocCodeKeywordSpan">get_grad</span>(ax,ay,d); // gradient from above, from chain
 rule
    for(var fx=0;fx&lt;f.sx;fx++) {
      for(var fy=0;fy&lt;f.sy;fy++) {
        for(var fd=0;fd&lt;f.depth;fd++) {
          var oy = y+fy;
          var ox = x+fx;
          if(oy&gt;=0 &amp;&amp; oy&lt;V.sy &amp;&amp; ox&gt;=0 &amp;&amp; ox&lt;V.sx) {
            // forward prop calculated: a += f.get(fx, fy, fd) * V.get(ox, oy, fd);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.Vol.prototype.set" id="apidoc.element.convnetjs.Vol.prototype.set">
        function <span class="apidocSignatureSpan">convnetjs.Vol.prototype.</span>set
        <span class="apidocSignatureSpan">(x, y, d, v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (x, y, d, v) {
  var ix=((this.sx * y)+x)*this.depth+d;
  this.w[ix] = v;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var W;
if(crop !== V.sx || dx!==0 || dy!==0) {
  W = new Vol(crop, crop, V.depth, 0.0);
  for(var x=0;x&lt;crop;x++) {
    for(var y=0;y&lt;crop;y++) {
      if(x+dx&lt;0 || x+dx&gt;=V.sx || y+dy&lt;0 || y+dy&gt;=V.sy) continue; // oob
      for(var d=0;d&lt;V.depth;d++) {
       W.<span class="apidocCodeKeywordSpan">set</span>(x,y,d,V.get(x+dx,y+dy,d)); // copy data over
      }
    }
  }
} else {
  W = V;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.Vol.prototype.setConst" id="apidoc.element.convnetjs.Vol.prototype.setConst">
        function <span class="apidocSignatureSpan">convnetjs.Vol.prototype.</span>setConst
        <span class="apidocSignatureSpan">(a)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setConst = function (a) { for(var k=0;k&lt;this.w.length;k++) { this.w[k] = a; }}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.Vol.prototype.set_grad" id="apidoc.element.convnetjs.Vol.prototype.set_grad">
        function <span class="apidocSignatureSpan">convnetjs.Vol.prototype.</span>set_grad
        <span class="apidocSignatureSpan">(x, y, d, v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set_grad = function (x, y, d, v) {
  var ix = ((this.sx * y)+x)*this.depth+d;
  this.dw[ix] = v;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } else {
    // bleh okay, lets do this the hard way
    var n=0; // counter for switches
    for(var x=0;x&lt;V2.sx;x++) {
      for(var y=0;y&lt;V2.sy;y++) {
        for(var i=0;i&lt;N;i++) {
          var chain_grad = V2.get_grad(x,y,i);
          V.<span class="apidocCodeKeywordSpan">set_grad</span>(x,y,this.switches[n],chain_grad);
          n++;
        }
      }
    }
  }
},
getParamsAndGrads: function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.convnetjs.Vol.prototype.toJSON" id="apidoc.element.convnetjs.Vol.prototype.toJSON">
        function <span class="apidocSignatureSpan">convnetjs.Vol.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
  // todo: we may want to only save d most significant digits to save space
  var json = {}
  json.sx = this.sx;
  json.sy = this.sy;
  json.depth = this.depth;
  json.w = this.w;
  return json;
  // we wont back up gradients to save space
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  json.out_sy = this.out_sy;
  json.layer_type = this.layer_type;
  json.l1_decay_mul = this.l1_decay_mul;
  json.l2_decay_mul = this.l2_decay_mul;
  json.pad = this.pad;
  json.filters = [];
  for(var i=0;i&lt;this.filters.length;i++) {
    json.filters.push(this.filters[i].<span class="apidocCodeKeywordSpan">toJSON</span>());
  }
  json.biases = this.biases.toJSON();
  return json;
},
fromJSON: function(json) {
  this.out_depth = json.out_depth;
  this.out_sx = json.out_sx;
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>